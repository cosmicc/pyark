#!/usr/bin/python3

import subprocess, time
import argparse, sqlite3
from configparser import ConfigParser
from datetime import datetime

configfile = '/home/ark/pyark.cfg'

class ExtConfigParser(ConfigParser):
    def getlist(self, section, option):
        value = self.get(section, option)
        return list(filter(None, (x.strip() for x in value.split(','))))

    def getlistint(self, section, option):
        return [int(x) for x in self.getlist(section, option)]

config = ExtConfigParser()
config.read(configfile)

sharedpath = config.get('general', 'shared')

sqldb = f'{sharedpath}/db/pyark.db'

def playedTime(ptime):
    total_min = ptime / 60
    minutes = int(total_min % 60)
    if minutes == 1:
        minstring = 'Min'
    else:
        minstring = 'Mins'
    hours = int(total_min / 60)
    if hours == 1:
        hourstring = 'Hour'
    else:
        hourstring = 'Hours'
    days = int(hours / 24)
    if days == 1:
        daystring = 'Day'
    else:
        daystring = 'Days'
    if days != 0:
        return('{} {}, {} {}'.format(days, daystring, hours-days*24, hourstring))
    elif hours != 0:
        return('{} {}, {} {}'.format(hours, hourstring, minutes, minstring))
    elif minutes != 0:
        return('{} {}'.format(minutes, minstring))
    else:
        return('Error')

def elapsedTime(start_time, stop_time, lshort=False):
    diff_time = start_time - stop_time
    total_min = diff_time / 60
    minutes = int(total_min % 60)
    if minutes == 1:
        if lshort is False:
            minstring = 'minute'
        else:
            minstring = 'min'
    else:
        if lshort is False:
            minstring = 'minutes'
        else:
            minstring = 'mins'
    hours = int(total_min / 60)
    if hours == 1:
        if lshort is False:
            hourstring = 'hour'
        else:
            hourstring = 'hr'
    else:
        if lshort is False:
            hourstring = 'hours'
        else:
            hourstring = 'hrs'
    days = int(hours / 24)
    if days == 1:
        if lshort is False:
            daystring = 'day'
        else:
            daystring = 'day'
    else:
        if lshort is False:
            daystring = 'days'
        else:
            daystring = 'days'
    if days != 0:
        return('{} {}, {} {} ago'.format(days, daystring, hours, hourstring))
    elif hours != 0:
        return('{} {}, {} {} ago'.format(hours, hourstring, minutes, minstring))
    elif minutes > 1:
        return('{} {} ago'.format(minutes, minstring))
    elif minutes <= 1:
        return('now')
    else:
        log.error('Elapsed time function failed. Could not convert.')
        return('Error')

print('    ')

conn = sqlite3.connect(sqldb)
c = conn.cursor()

now = time.time()

c.execute('DELETE from players WHERE playedtime = 0')
conn.commit()

c.execute('SELECT * from players')
allplayers = c.fetchall()

def howmanyon(inst):
    pcnt = 0
    for row in allplayers:
        #print(row)
        diff_time = float(now) -  float(row[2])
        total_min = diff_time / 60
        minutes = int(total_min % 60)
        hours = int(total_min / 60)
        days = int(hours / 24)
        if minutes <= 1 and hours < 1 and days < 1 and row[3] == inst:
            pcnt += 1
    return pcnt

for row in allplayers:
    #print(row)
    if row[0] == '' or row[0].startswith(' '):
        print(f'deleting id: {row[0]}')
        c.execute('DELETE from players WHERE steamid = ?', (row[0],))
    else:
        active = ''
        pltime = playedTime(float(row[4].replace(',','')))
        laston = elapsedTime(float(now),float(row[2]))
        diff_time = float(now) -  float(row[2])
        total_min = diff_time / 60
        minutes = int(total_min % 60)
        hours = int(total_min / 60)
        days = int(hours / 24)
        if minutes <= 1 and hours < 1 and days < 1:
            active = '*'
        firston = datetime.fromtimestamp(float(row[6])-14400).strftime('%a, %b %d %I:%M%p')
        print(f'{row[0]} {active}\"{row[1]}\" - Connections: {row[7]} - Reward Points: {row[5]}')
        print(f' FirstON: {firston} | PlayedTime: {pltime} | LastON: {laston} on {row[3]}')
        print('  ')

print('      ')

c.execute('SELECT cfgver from general')
gencfgver = c.fetchone()

c.execute('SELECT * from instances')
allservers = c.fetchall()

for each in allservers:

    restarted = elapsedTime(float(now),float(each[1]))
    lwipe = elapsedTime(float(now),float(each[2]))
    lvote = elapsedTime(float(now),float(each[4]))
    ply = howmanyon(each[0])
    if gencfgver[0] != each[6]:
        vertxt = f'({int(gencfgver[0])-int(each[6])} version behind)'
    else:
        vertxt = '(Current)'

    print(f'Server: {each[0].upper()} - Players: {ply}/50')
    print(f'Configuration version: {each[6]} {vertxt}')
    print(f'Server in restart: {each[3]}')
    print(f'Last restart: {restarted} - Reason: {each[5]}')
    print(f'Last wilddino wipe: {lwipe}')
    print(f'Last wipe vote: {lvote}')
    print('  ')

print('        ')
conn.commit()
c.close()
conn.close()

