#!/usr/bin/env python3.7
import argparse
import asyncio
import uvloop
from pathlib import Path
from sys import exit
from time import sleep

import psutil
from loguru import logger as log

import modules.logging
from modules.asyncdb import DB as db
from modules.configreader import hstname, instances, sharedpath
from modules.players import asyncgetliveplayersonline
from modules.pushover import pushover
from modules.servertools import asyncserverexec, setarknice
from modules.timehelper import Now, Secs, elapsedTime

__author__ = "Ian Perry"
__copyright__ = "Copyright 2018, Galaxy Media"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Ian Perry"
__email__ = "ianperry99@gmail.com"
__progname__ = "pyark-daemon"
__description__ = "ark instance watchdog service"
__detaildesc__ = ""
__name__ = "arkwatchdog"

parser = argparse.ArgumentParser(prog=__progname__)
parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-q', '--quiet', action='store_true',
                    help='supress logging output to console. default: error logging')
parser.add_argument('-d', '--debug', action='store_true', help='verbose output (debug)')
parser.add_argument('-t', '--trace', action='store_true', help='super verbose output (trace)')
args = parser.parse_args()

stop_event = True

sharepath = Path(sharedpath)
instpidfiles = {}
for inst in instances:
    instpidfiles.update({inst: Path(f'/home/ark/ARK/ShooterGame/Saved/.arkserver-{inst}.pid')})


def issharedmounted():
    return sharepath.is_mount()


def float_trunc_1dec(num):
    try:
        tnum = num // 0.1 / 10
    except:
        return False
    else:
        return tnum


def getinstpid(inst):
    return instpidfiles[inst].read_text()


async def getopenfiles():
    result = await asyncserverexec(['sysctl', 'fs.file-nr'], nice=19, wait=True)
    newresult = result['stdout'].decode('utf-8').strip().split(' ')[2].split('\t')
    return (newresult[0], newresult[2])


async def getserveruptime():
    return elapsedTime(Now(), psutil.boot_time())


async def getcpuload():
    rawcpuload = psutil.getloadavg()
    numcores = psutil.cpu_count()
    cpufreq = psutil.cpu_freq()[0] / 1000
    load1 = (rawcpuload[0] / numcores) * 100
    load5 = (rawcpuload[1] / numcores) * 100
    load15 = (rawcpuload[2] / numcores) * 100
    return (numcores, float_trunc_1dec(cpufreq), float_trunc_1dec(load1), float_trunc_1dec(load5), float_trunc_1dec(load15))


async def getservermem():
    process = await asyncserverexec(['free', '-m'], nice=19, wait=True)
    lines = process['stdout'].decode().split('\n')
    memvalues = lines[1].strip().split()
    swapvalues = lines[2].strip().split()
    memfree = memvalues[3]
    memavailable = memvalues[6]
    swapused = swapvalues[2]
    return (memfree, memavailable, swapused)


async def processinststats(inst):
    log.trace(f'Running process instances stats for {inst}')
    instpid = getinstpid(inst)
    arkprocess = psutil.Process(instpid)
    arkcpu = arkprocess.cpu_percent(interval=2)
    rawsts = await asyncserverexec(['ps', '-p', f'{instpid}', '-o', 'rss,vsz'], nice=19, wait=True)
    instrss, instvsz = rawsts['stdout'].decode('utf-8').split('\n')[1].split(' ')
    instrss = int(instrss) / 1000000 // 0.01 / 100
    instvsz = int(instvsz) / 1000000 // 0.01 / 100
    await db.update(f"UPDATE instances SET actmem = '{instrss}', totmem = '{instvsz}', serverpid = '{instpid}', arkcpu = '{arkcpu}' WHERE name = '{inst}'")


async def processserverstats():
    log.trace('Running process server stats')
    serveruptime = await getserveruptime()
    servermem = await getservermem()
    serverload = await getcpuload()
    openfiles = await getopenfiles()
    for inst in instances:
        await db.update(f"UPDATE instances SET openfiles = '{openfiles[0]}', cpucores = '{serverload[0]}', cpufreq = '{serverload[1]}', cpuload1 = '{serverload[2]}', cpuload5 = '{serverload[3]}', cpuload15 = '{serverload[4]}', svrmemfree = '{servermem[0]}', svrmemavail = '{servermem[1]}', svrswapused = '{servermem[2]}', serveruptime = '{serveruptime}' WHERE name = '{inst}'")


async def asyncmain():
    log.debug('Starting server/ark stat processor loop')
    while stop_event:
        asyncio.create_task(processserverstats())
        await asyncio.sleep(5)
        asyncio.create_task(processserverstats())
        await asyncio.sleep(55)


def main():
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    if args.trace:
#        warnings.simplefilter('always', ResourceWarning)
        asyncio.run(asyncmain(), debug=True)  # Async branch to main loop
    else:
        asyncio.run(asyncmain())


async def asyncwatchdog():
    isrunning = {}
    isonline = {}
    log.log('START', f'Watchdog Daemon is starting on [{hstname}]')
    if len(instances) > 0:
        if await asyncdidserverjustboot():
            log.log('WATCH', 'server just booted, starting instances for the first time')
            while not issharedmounted():
                log.log('WATCH', 'Shared drive is not mounted, waiting for mount to complete...')
                await asyncio.sleep(60)
            if await issharedmounted():
                for inst in instances:
                    await asyncserverexec(['arkmanager', 'start', f'@{eat["name"]}'], nice=-1)
                    await asyncio.sleep(120)

    log.debug('starting watchdog loop')
    serverstatcount = 0
    while True:
        try:
            if hstname.upper() != 'SVRDB':
                if serverstatcount == 5:
                    serverstatcount = 0
                serverstatcount += 1
                if serverstatcount == 1:
                    log.trace(f'Updating server stats for server {hstname.upper()}')
                    memfree, memavail, swapused = getservermem()
                    cpucores, cpufreq, cpuload1, cpuload5, cpuload15 = getcpustats()
                    uptime = getserveruptime()
                ofiles = getopenfiles()
            for inst in instances:
                if await asyncisinstanceenabled(inst):
                    isitrunning, isitlistening, isitonline = getinststatus(eachinst['name'])
                    if isitrunning:
                        log.trace(f'{inst} passed instance running check')
                        setarknice(eachinst["name"])
                        try:
                            log.trace(f'updating process stats for {eachinst["name"]}')
                            arkservercpu = float_trunc_1dec(arkprocesscpu(eachinst["name"]))
                            actmem, totmem = getinstmem(eachinst['name'])
                            dbupdate("UPDATE instances SET actmem = '%s', totmem = '%s', arkcpu = '%s' WHERE name = '%s'" % (actmem, totmem, arkservercpu, eachinst['name']))
                        except:
                            log.log('WATCH', f'Failed to get ark process info for [{eachinst["name"]}]')
                        for neach in isrunning.copy():
                            if neach == eachinst['name']:
                                isrunning.update({inst: {'isit': 1, 'count': 0}})
                    elif Now() - int(getlaststart(eachinst['name'])[0]) > Secs['3min']:
                        for neach in isrunning.copy():
                            if neach == eachinst['name']:
                                isrunning.update({inst: {'isit': 0, 'count': isrunning[neach]['count'] + 1}})
                                if isrunning[inst]['count'] > 2:
                                    log.warning(f'[{eachinst["name"].title()}] failed instance running check ({isrunning[neach]["count"]}/5)')
                                    dbupdate("UPDATE instances SET isup = 0 WHERE name = '%s'" % (eachinst['name'],))
                    else:
                        log.debug(f'skipping running check for 3 min startup for {eachinst["name"]}')

                    if isitrunning and not isitonline and Now() - int(getlaststart(eachinst['name'])[0]) > Secs['10min']:
                        for neach in isonline.copy():
                            if neach == eachinst['name']:
                                isonline.update({inst: {'isit': 0, 'count': isonline[neach]['count'] + 1}})
                                if isonline[inst]['count'] > 5:
                                    log.warning(f'[{eachinst["name"].title()}] failed instance online check ({isonline[neach]["count"]}/10)')
                                    dbupdate("UPDATE instances SET isup = 0 WHERE name = '%s'" % (eachinst['name'],))

                    elif isitonline:
                        log.trace(f'{eachinst["name"]} passed instance online check')
                        dbupdate("UPDATE instances SET uptimestamp = '%s', isup = 1 WHERE name = '%s'" % (Now(), eachinst['name']))
                        for neach in isonline.copy():
                            if neach == eachinst['name']:
                                isonline.update({inst: {'isit': 1, 'count': 0}})
                    else:
                        log.debug(f'skipping online check for 10 min startup for {eachinst["name"]}')

                    for feach in isrunning:
                        if feach == eachinst['name']:
                            if isrunning[inst]['count'] == 5:
                                isrunning.update({inst: {'isit': 0, 'count': 0}})
                                isonline.update({inst: {'isit': 0, 'count': 0}})
                                log.warning(f'Instance [{eachinst["name"]}] failed running checks! Starting Instance')
                                pmsg = f'Instance {eachinst["name"]} failed running checks!\nStarting Instance'
                                pushover('Watchdog', pmsg)
                                startserver(eachinst['name'])
                    for feach in isonline:
                        if feach == eachinst['name']:
                            if isonline[inst]['count'] == 10:
                                oplayers = await asyncgetliveplayersonline({eachinst["name"]})
                                isrunning.update({inst: {'isit': 0, 'count': 0}})
                                isonline.update({inst: {'isit': 0, 'count': 0}})
                                if int(oplayers[0]) == 0 and int(oplayers[1]) == 0:
                                    log.warning(f'Instance [{eachinst["name"]}] failed online checks! Restarting Instance')
                                    pmsg = f'Instance {eachinst["name"]} failed online checks!\nRestarting Instance'
                                    pushover('Watchdog', pmsg)
                                    startserver(eachinst['name'])
                                else:
                                    log.info(f'Skipping instance restart because players are actually online')
                    if serverstatcount == 1:
                        await db.update("UPDATE instances SET serverhost = '%s', svrmemfree = '%s', svrmemavail = '%s', svrswapused = '%s', cpucores = '%s', cpufreq = '%s', cpuload1 = '%s', cpuload5 = '%s', cpuload15 = '%s', serveruptime = '%s', openfiles = '%s' WHERE name = '%s'" % (hstname, int(memfree), int(memavail), int(swapused), int(cpucores), cpufreq, cpuload1, cpuload5, cpuload15, uptime, ofiles['openfiles'], eachinst['name']))

        except KeyboardInterrupt:
            log.critical('Keyboard Interrupt Detected, Exiting.')
            exit()
        except:
            log.exception('Critical Error in Ark Watchdog!')
        log.trace('sleeping 1 min between checks')
        try:
            sleep(Secs['1min'])
            checkpyark()
        except KeyboardInterrupt:
            log.critical('Keyboard Interrupt Detected, Exiting.')
            exit()


if __name__ == 'arkwatchdog':
    main()
