#!/usr/bin/python3

import subprocess, time, logging, argparse, sqlite3, json
from datetime import datetime
from colorizer import *
from timehelper import elapsedTime, estshift, playedTime, wcstamp
from configreader import config, sqldb
from urllib.request import urlopen, Request

parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('action_to_perform',
                    action='store', choices=['servers', 'players', 'kicklist', 'linkrequests', 'delplayer',
                                             'linkplayer', 'startlottery', 'lottery', 'restartserver', 'chatbuffer',
                                             'servertable', 'discordnames', 'notlinked', 'newest', 'server', 'dinowipe',
                                             'playersraw', 'logwatch', 'lotterytables', 'log', 'topplayers',
                                             'debugwatch', 'playertable', 'oldest', 'logsearch', 'banplayer', 'banlist',
                                             'unbanplayer', 'tribewipe', 'backupdb'], help='Action to perform')
action_group = parser.add_argument_group(title='actions')
action_group.add_argument('servers', action='store_true', help='Server infomration')
action_group.add_argument('playertable', action='store_true', help='Show players table')
action_group.add_argument('kicklist', action='store_true', help='Show kick list table')
action_group.add_argument('linkrequests', action='store_true', help='Show link requests table')
action_group.add_argument('discordnames', action='store_true', help='Show discord users table')
action_group.add_argument('restartserver', action='store_true', help='Set a server for admin restart')
action_group.add_argument('delplayer', action='store_true', help='Remove a player from the table')
action_group.add_argument('linkplayer', action='store_true', help='Link a player to a discord user')
action_group.add_argument('notlinked', action='store_true', help='Show players not linked to discord')
action_group.add_argument('newest', action='store_true', help='Show last 10 newest players joined')
action_group.add_argument('oldest', action='store_true', help='Show last 10 oldest players lastseen')
action_group.add_argument('server', action='store_true', help='Server information')
action_group.add_argument('players', action='store_true', help='Show players by last time seen')
action_group.add_argument('chatbuffer', action='store_true', help='Show the chat buffer table')
action_group.add_argument('servertable', action='store_true', help='Show the servers table table')
action_group.add_argument('dinowipe', action='store_true', help='Initiate a wild dino wipe on a server')
action_group.add_argument('playersraw', action='store_true', help='Show raw player list')
action_group.add_argument('logwatch', action='store_true', help='Log Watcher')
action_group.add_argument('debugwatch', action='store_true', help='Debug Log Watcher')
action_group.add_argument('logsearch', action='store_true', help='Seach log by string (with -l)')
action_group.add_argument('banplayer', action='store_true', help='Ban a player from the cluster')
action_group.add_argument('unban', action='store_true', help='UN-Ban a player from the cluster')
action_group.add_argument('banlist', action='store_true', help='Show the list of banned players')
action_group.add_argument('tribewipe', action='store_true', help='Wipe a tribe, its dinos and belongings from a server')
action_group.add_argument('backupdb', action='store_true', help='Run a manual pyark database backup')
action_group.add_argument('lotterytables', action='store_true', help='Show Lottery tables')
action_group.add_argument('startlottery', action='store_true', help='Start a lottery')
action_group.add_argument('lottery', action='store_true', help='Show Lottery Info')
action_group.add_argument('topplayers', action='store_true', help='Show Top Players')
action_group.add_argument('log', action='store_true', help='Show the log (requires log length)')

parser.add_argument('-s', '--servername', action='store', help='Ark server instance name')
parser.add_argument('-c', '--cancel', action='store_true', help='Cancel a instance restart')
parser.add_argument('-l', '--searcharg', action='store', help='Search string for log file searching')
parser.add_argument('-j', '--loglines', action='store', help='Number of log lines to show')

args = parser.parse_args()

log = logging.getLogger()
log.setLevel(logging.INFO)
console_format = logging.Formatter('%(asctime)s:[%(levelname)s]:%(message)s')
log_console = logging.StreamHandler()
log.addHandler(log_console)
log_console.setFormatter(console_format)

configfile = '/home/ark/pyark.cfg'

clr1 = f'{BYEL}'
clr2 = f'{BCYN}'

tclr = ''
trclr = ''

print('    ')

conn = sqlite3.connect(sqldb)
c = conn.cursor()

now = time.time()

c.execute('DELETE from players WHERE playedtime = 0')
conn.commit()


def fetcharkserverdata(key):
    url = f'https://ark-servers.net/api/?object=servers&element=detail&key={key}'
    req = Request(url, headers={'User-Agent': 'Mozilla/5.0'})
    html = urlopen(req).read()
    adata = json.loads(html)
    return adata


def sendtoserver(tribeid):
    sshuser = config.get('general', 'sshuser').rstrip()
    sshhost = config.get('general', 'otherserverip').rstrip()
    sshpass = config.get('general', 'sshpass').rstrip()
    commands = f"""arkmanager rconcmd "saveworld" @all && arkmanager backup @all && arkmanager rconcmd \
"DestroyTribeIdDinos {tribeid}" @all && arkmanager rconcmd "DestroyTribeIdStructures {tribeid}" @all && \
arkmanager rconcmd "DestroyTribeIdPlayers {tribeid}" @all && arkmanager rconcmd "DestroyTribeId {tribeid}" @all"""
    command = f"""sshpass -p {sshpass} ssh {sshuser}@{sshhost} '{commands}'"""
    subprocess.run(command, shell=True)


def printplayer(feach):
    print(f'{BWHT}{feach[0]} {BMGT}{feach[1].capitalize()}{RST} {WHT}last on {tclr}{elapsedTime(now,float(feach[2]))} \
{WHT}ago on {BMGT}{feach[3].capitalize()} {WHT}Home Server: {BCYN}{feach[15].capitalize()} {WHT}Discord: \
{BWHT}{feach[8]}{RST}')
    print(f'{WHT}Connections: {BGRN}{feach[7]} {WHT}Total Playtime: {BCYN}{playedTime(feach[4])} {WHT}joined \
{trclr}{elapsedTime(now,float(feach[6]))}{WHT} ago{RST}')
    print(f'{WHT}Points: {BGRN}{feach[5]} {WHT}Transfer Points: {BGRN}{feach[16]} {WHT}Auctions: {BGRN}{feach[10]} \
({feach[11]}/{feach[12]}) {WHT}Primordial Warning: {BCYN}{feach[14]} {WHT}Lotto Wins: {BGRN}{feach[18]}{RST}\n')


def alogsearcher(searchparm):
    log_file_path = '/home/ark/shared/logs/pyark/pyark.log'
    print(f'{BMGT}log {RST}')
    print('   ')
    with open(log_file_path, "r") as in_file:
        for line in in_file:
            if (line.find(searchparm)) != -1:
                # if jk = 0: ################
                print(f'{nc}{line}{RST}', end='', flush=True)
    print('   ')
    print(f'{BGRN}Complete.{RST}')


def printarkserverdata(sdata):
    if int(sdata['is_online']) == 1:
        fug = f'{BGRN}True{RST}'
    else:
        fug = f'{BRED}False{RST}'
    print(f'{BYEL}Hostname: {BMGT}{sdata["hostname"]}{RST}')
    print(f'{BYEL}Ark Server Name: {BCYN}{sdata["name"]}{RST}')
    print(f'{BYEL}Address: {BMGT}{sdata["address"]}{RST}  {BYEL}Port: {BMGT}{sdata["port"]}{BYEL}  Query Port: \
{BMGT}{sdata["query_port"]}{BYEL}  Map: {BMGT}{sdata["map"]}{RST}')
    print(f'{BYEL}Server Version: {BMGT}{sdata["version"]}{BYEL}  Online: {fug}{BYEL}  Uptime: {BMGT}{sdata["uptime"]}{BYEL}')
    print(f'{BYEL}Rank: {BCYN}{sdata["rank"]}{BYEL}  Score: {BCYN}{sdata["score"]}{BYEL}  Votes: \
{BCYN}{sdata["votes"]}{BYEL}  Favorited: {BCYN}{sdata["favorited"]}{BYEL}  Comments: {BCYN}{sdata["comments"]}{RST}')
    print(f'{BYEL}Ark-Servers URL: {BMGT}{sdata["url"]}{RST}')
    print(f'{BYEL}Last Update: {BCYN}{sdata["last_check"]}{RST}')
    print(f'{BYEL}Last Online: {BCYN}{sdata["last_online"]}{RST}')
    print('  ')


def printserverinfo(each):
    c.execute('SELECT * from players')
    allplayers = c.fetchall()
    c.execute('SELECT cfgver from general')
    gencfgver = c.fetchone()

    def howmanyon(inst):
        pcnt = 0
        for row in allplayers:
            # print(row)
            diff_time = float(now) - float(row[2])
            total_min = diff_time / 60
            minutes = int(total_min % 60)
            hours = int(total_min / 60)
            days = int(hours / 24)
            if minutes <= 1 and hours < 1 and days < 1 and row[3] == inst:
                pcnt += 1
        return pcnt
    restarted = elapsedTime(float(now), float(each[1]))
    if float(now) - float(each[1]) > 259200:
        restclr = f"{BRED}"
    elif float(now) - float(each[1]) > 172800:
        restclr = f"{BYEL}"
    else:
        restclr = f"{BGRN}"
    lwipe = elapsedTime(float(now), float(each[2]))
    if float(now) - float(each[2]) > 86400:
        wipeclr = f"{BRED}"
    elif float(now) - float(each[2]) > 43200:
        wipeclr = f"{BYEL}"
    else:
        wipeclr = f"{BGRN}"
    lvote = elapsedTime(float(now), float(each[4]))
    if float(now) - float(each[4]) > 259200:
        voteclr = f"{BRED}"
    elif float(now) - float(each[4]) > 86400:
        voteclr = f"{BYEL}"
    else:
        voteclr = f"{BGRN}"
    ply = howmanyon(each[0])
    if gencfgver[0] != each[6]:
        vertxt = f'{BRED}({int(gencfgver[0]) - int(each[6])} versions behind){RST}'
    else:
        vertxt = f'{GRN}(Current){RST}'
    if each[3] == "False":
        inrest = f"{GRN}False{RST}"
    else:
        inrest = f"{BRED}TRUE{RST}"
    if ply != 0:
        mm = BGRN
    else:
        mm = BRED
    if each[7] < 5:
        nn = BRED
    elif each[7] < 15:
        nn = YEL
    else:
        nn = BGRN
    if each[3] == "True":
        tls = f'Time Left: {nn}{each[7]} Minutes'
    else:
        tls = ''
    if int(each[9]) == 0:
        iso = f'{BRED}NO{RST}'
    elif int(each[9]) == 1:
        iso = f'{BGRN}Yes{RST}'
    if int(each[10]) == 0:
        isl = f'{BRED}NO{RST}'
    elif int(each[10]) == 1:
        isl = f'{BGRN}Yes{RST}'
    if int(each[11]) == 0:
        isr = f'{BRED}NO{RST}'
    elif int(each[11]) == 1:
        isr = f'{BGRN}Yes{RST}'
    if time.time() - float(each[12]) > 600:
        boo = f'{BRED}'
    else:
        boo = f'{BGRN}'
    lastuc = elapsedTime(time.time(), float(each[12]))
    print(f'{WHT}Server: {BMGT}{each[0].upper()}{WHT}  Players: {mm}{ply}/50{RST}')
    print(f'{WHT}Online: {iso}  {WHT}Listening: {isl}  {WHT}Running: {isr}  {WHT}Last Check: {boo}{lastuc}{RST}')
    print(f'{WHT}Active Memory: {BYEL}{each[13]} Gig{WHT}  Total Memory: {BYEL}{each[14]} Gig{RST}')
    print(f'{WHT}Configuration version: {BCYN}{each[6]}{RST} {vertxt}')
    print(f'{WHT}Server in restart: {inrest} {WHT}{tls}{RST}')
    print(f'{WHT}Last restart: {restclr}{restarted}{WHT}  Reason: {BCYN}{each[5]}{RST}')
    print(f'{WHT}Last wilddino wipe: {wipeclr}{lwipe}{RST}')
    print(f'{WHT}Last wipe vote: {voteclr}{lvote}{RST}')
    print('  ')


def playersraw():
    c.execute('SELECT * from players')
    allplayers = c.fetchall()
    for row in allplayers:
        pltime = playedTime(float(row[4].replace(',', '')))
        laston = elapsedTime(float(now), float(row[2]))
        diff_time = float(now) - float(row[2])
        total_min = diff_time / 60
        minutes = int(total_min % 60)
        hours = int(total_min / 60)
        days = int(hours / 24)
        if minutes <= 1 and hours < 1 and days < 1:
            active = BGRN
        elif days > 7 <= 14:
            active = YEL
        elif days > 14:
            active = BRED
        else:
            active = BCYN
        firston = datetime.fromtimestamp(float(row[6]) - 14400).strftime('%a, %b %d %I:%M%p')
        print(f'{active}{row[0]} \"{row[1]}\" - Connections: {row[7]} - Reward Points: {row[5]}')
        print(f' FirstON: {firston} | PlayedTime: {pltime} | LastON: {laston} on {row[3]}{RST}')
        print('  ')


def showservers():
    global tclr
    global trclr
    c.execute('SELECT cfgver from general')
    gencfgver = c.fetchone()
    print(f'{BYEL}CURRENT CONFIG VERSION: {BCYN}{gencfgver[0]}{RST}')
    print('    ')
    c.execute('SELECT * from instances')
    allservers = c.fetchall()
    for each in allservers:
        printserverinfo(each)
    lst = time.time() - 41
    c.execute('SELECT * from players WHERE lastseen > ?', (lst, ))
    lastones = c.fetchall()
    jo = len(lastones)
    if jo == 0:
        moo = f'{BRED}'
    else:
        moo = f'{BGRN}'
    print(f'{BYEL}CLUSTER PLAYERS ONLINE: {moo}{jo}{RST}')
    print('   ')
    for feach in lastones:
        tt = now - float(feach[2])
        tr = now - float(feach[6])
        if tt < 86400:
            tclr = f'{BGRN}'
        elif tt < 604800:
            tclr = f'{YEL}'
        else:
            tclr = f'{RED}'
        if tr < 604800:
            trclr = f'{BGRN}'
        elif tr < 2592000:
            trclr = f'{YEL}'
        else:
            trclr = f'{RED}'
        printplayer(feach)


def restartserver(server):
    if not args.cancel:
        c.execute('UPDATE instances SET needsrestart = "True", restartreason = "admin restart" WHERE name = ?', (server, ))
        print(f'{BYEL}server {BMGT}{server}{BYEL} has been set to {BRED}RESTART{RST}')
    else:
        c.execute('UPDATE instances SET needsrestart = "False" WHERE name = ?', (server, ))
        print(f'{BYEL}server {BMGT}{server}{BYEL} has been set to {BGRN}NOT RESTART{RST}')
    conn.commit()


def printcolmns(mtable):
    c.execute('PRAGMA table_info({})'.format(mtable))
    alldata = c.fetchall()
    ap = []
    for row in alldata:
        ap.append(f'{row[1]}[{row[0]}] {row[2]}')
    print(f'{BMGT}{ap}{RST}')
    print('  ')


def listtablewhere(mtable, colmn, val):
    # print(mtable,colmn,val)
    c.execute('SELECT * from {} WHERE {} = ""'.format(mtable, colmn))
    showtable(mtable, c.fetchall())


def listtable(mtable):
    c.execute('SELECT * from {}'.format(mtable))
    showtable(mtable, c.fetchall())


def showtable(mtable, aplay):
    sc = 0
    cnt = 0
    if aplay:
        for each in aplay:
            cnt += 1
            if sc == 0:
                sclr = f'{clr1}'
            else:
                sclr = f'{clr2}'
            print(f'{sclr}{each}{RST}')
            if sc == 1:
                sc = 0
            else:
                sc = 1
        print('   ')
        print(f'{BWHT}Table: {BGRN}{mtable}{BWHT} Total rows: {BMGT}{cnt}{RST}')
    else:
        print(f'{BYEL}{mtable} table is empty.{RST}')


def getresponce(question):
    print('    ')
    check = str(input(f"{question} : ")).lower().strip()
    try:
        return check
    except Exception as error:
        print("Please enter valid inputs")
        print(error)
        return ask_user()

def ask_question(question):
    print('   ')
    check = str(input(f"{question} (Y/N): ")).lower().strip()
    try:
        if check[0] == 'y':
            return True
        elif check[0] == 'n':
            return False
        else:
            print('Invalid Input')
            return ask_user()
    except Exception as error:
        print("Please enter valid inputs")
        print(error)
        return ask_user()


def linkplayer():
    printcolmns('players')
    listtable('players')
    nsteamid = getresponce(f'{BGRN}Enter Steam ID of player to add a discord ID too{RST}')
    print('    ')
    printcolmns('discordnames')
    listtable('discordnames')
    sdid = getresponce(f'{BGRN}Enter Discord Name to add to player {nsteamid}{RST}')
    if ask_question(f'{BGRN}Add Discord Name: {BMGT}{sdid}{BGRN} to Steam ID {BMGT}{nsteamid}{BYEL}?{RST}'):
        c.execute('UPDATE players SET discordid = ? WHERE steamid = ?', (sdid, nsteamid))
        print('    ')
        print(f'{BYEL}Discord Name: {BMGT}{sdid}{BYEL} has been added to {BMGT}{nsteamid}{RST}')
        print('    ')
    else:
        print('    ')
        print(f'{BRED}Canceled. Nothing written{RST}')
        print('    ')
    conn.commit()
    printcolmns('players')
    listtable('players')


def delplayer():
    printcolmns('players')
    listtable('players')
    nsteamid = getresponce(f'{BGRN}Enter Steam ID of player to DELETE{RST}')
    c.execute('SELECT * from players')
    oplayers = c.fetchall()
    for each in oplayers:
        if each[0] == nsteamid:
            if ask_question(f'{BGRN}You will be DELETING {BMGT}{each[1]}{BGRN} with steamid {BMGT}{each[0]}{BGRN} \
from the database. continue?{RST}'):
                c.execute('DELETE from players WHERE steamid = ?', (nsteamid,))
                print('    ')
                print(f'{BYEL}Player {BMGT}{each[1]}{BYEL} with steamid {BMGT}{each[0]}{BYEL} has been deleted.{RST}')
                print('    ')
            else:
                print('    ')
                print(f'{BRED}Canceled. Skipping delete{RST}')
                print('   ')
    conn.commit()
    c.execute('SELECT * from players')
    alldata = c.fetchall()
    for row in alldata:
        print(row)


def banplayer():
    printcolmns('players')
    listtable('players')
    nsteamid = getresponce(f'{BGRN}Enter Steam ID of player to BAN{RST}')
    c.execute('SELECT * from players')
    oplayers = c.fetchall()
    juu = 'noname'
    for each in oplayers:
        if each[0] == nsteamid:
            juu = each[1]
    if ask_question(f'{BGRN}You will be BANNING {BMGT}{juu}{BGRN} with steamid {BMGT}{nsteamid}{BGRN} from the \
cluster. continue?{RST}'):
        if juu != 'noname':
            c.execute('UPDATE players SET banned = ? WHERE steamid = ?', (time.time(), nsteamid))
            conn.commit()
        c.execute('SELECT * from banlist WHERE steamid = ?', (nsteamid, ))
        blid = c.fetchall()
        if not blid:
            c.execute('INSERT INTO banlist (steamid) VALUES (?)', (nsteamid, ))
            conn.commit()
        print('    ')
        print(f'{BYEL}Player {BMGT}{each[1]}{BYEL} with steamid {BMGT}{each[0]}{BYEL} has been BANNED from all servers \
in the cluster!{RST}')
        print('    ')
    else:
        print('    ')
        print(f'{BRED}Canceled. Skipping ban{RST}')
        print('    ')
    c.execute('SELECT * from banlist')
    alldata = c.fetchall()
    for row in alldata:
        print(row)


def unbanplayer():
    printcolmns('players')
    listtable('players')
    nsteamid = getresponce(f'{BGRN}Enter Steam ID of player to UN-BAN{RST}')
    c.execute('SELECT * from players')
    oplayers = c.fetchall()
    juu = 'noname'
    for each in oplayers:
        if each[0] == nsteamid:
            juu = each[1]
    if ask_question(f'{BGRN}You will be UN-BANNING {BMGT}{juu}{BGRN} with steamid {BMGT}{nsteamid}{BGRN} \
from the cluster. continue?{RST}'):
        if juu != 'noname':
            c.execute('UPDATE players SET banned = "" WHERE steamid = ?', (nsteamid,))
            conn.commit()
        c.execute('SELECT * from banlist WHERE steamid = ?', (nsteamid,))
        blid = c.fetchall()
        if blid:
            c.execute('DELETE FROM banlist WHERE steamid = ?', (nsteamid,))
            conn.commit()
        print('    ')
        print(f'{BYEL}Player {BMGT}{each[1]}{BYEL} with steamid {BMGT}{each[0]}{BYEL} has been UN-BANNED from \
all servers in the cluster!{RST}')
        print('    ')
    else:
        print('    ')
        print(f'{BRED}Canceled. Skipping un-ban{RST}')
        print('    ')
    c.execute('SELECT * from banlist')
    alldata = c.fetchall()
    for row in alldata:
        print(row)


def banlist():
    c.execute('SELECT * from players WHERE banned != ""')
    oplayers = c.fetchall()
    for each in oplayers:
        print(f'{BCYN}{each}{RST}')
    if not oplayers:
        print(f'{BGRN}No player list bans{RST}')
    print('    ')
    c.execute('SELECT * from banlist')
    oplayers = c.fetchall()
    for each in oplayers:
        print(f'{BYEL}{each}{RST}')
    if not oplayers:
        print(f'{BGRN}No ids in ban list{RST}')
    print('    ')


def newest():
    global tclr
    global trclr
    print(f'{BCYN}TOP 10 NEWEST CLUSTER PLAYERS:{RST}')
    print('   ')
    c.execute('SELECT * from players ORDER BY firstseen DESC LIMIT 10')
    lastones = c.fetchall()
    for feach in lastones:
        tt = now - float(feach[2])
        tr = now - float(feach[6])
        if tt < 86400:
            tclr = f'{BGRN}'
        elif tt < 604800:
            tclr = f'{YEL}'
        else:
            tclr = f'{RED}'
        if tr < 604800:
            trclr = f'{BGRN}'
        elif tr < 2592000:
            trclr = f'{YEL}'
        else:
            trclr = f'{RED}'
        printplayer(feach)


def topplayers():
    ppc = 0
    lastones = []
    print(f'{BCYN}TOP 10 PLAYTIME PLAYERS ALL TIME:{RST}')
    print('   ')
    c.execute('SELECT * from players')
    llast = c.fetchall()
    lastones = [list(elem) for elem in llast]
    for f in range(len(lastones)):
        lastones[f][4] = float(str(lastones[f][4]).replace(',', ''))
    lastones.sort(key=lambda x: x[4], reverse=True)
    for feach in lastones:
        ppc += 1
        if ppc <= 10:
            printplayer(feach)
    # print(f'{BCYN}TOP 5 PLAYTIME PLAYERS LAST WEEK:{RST}')
    # ppc = 1
    # for feach in lastones:
    #    if ppc <= 5 and time.time()-float(feach[2]) < 604800:
    #        ppc += 1
    #        printplayer(feach)


def tribewipe():
    tribeid = getresponce(f'{BGRN}Enter Tribe ID of tribe to DESTROY{RST}')
    if ask_question(f'{BGRN}You will be DESTROYING {BMGT}{tribeid}{BGRN} from the cluster. continue?{RST}'):
        subrun = f"""arkmanager rconcmd 'DestroyTribeIdStructures {tribeid}' @ragnarok"""
        subprocess.run(subrun, shell=True)
        # subrun = f"""arkmanager rconcmd 'DestroyTribeIdDinos {tribeid}' @all && arkmanager rconcmd \
        # 'DestroyTribeIdStructures {tribeid}' @all && arkmanager rconcmd 'DestroyTribeIdPlayers \
        # {tribeid}' @all && arkmanager rconcmd 'DestroyTribeId {tribeid}' @all"""
        print('    ')
        print(f'{BYEL}Removing tribeid {BMGT}{tribeid}{BYEL} from local server{RST}')
        print('   ')
        # subprocess.run('arkmanager rconcmd "saveworld" @all && arkmanager backup @all', shell=True)
        subprocess.run(subrun, shell=True)
        print(f'{BYEL}Removing tribeid {BMGT}{tribeid}{BYEL} from remote server{RST}')
        # sendtoserver(tribeid)
        # print('   ')
        # print(f'{BGRN}TribeID {BMGT}{tribeid}{BGRN} has been DESTROYED from all servers!{RST}')


def oldest():
    global tclr
    global trclr
    print(f'{BCYN}TOP 10 OLDEST LAST TIME SEEN PLAYERS:{RST}')
    print('   ')
    c.execute('SELECT * from players ORDER BY lastseen ASC LIMIT 10')
    lastones = c.fetchall()
    for feach in lastones:
        tt = now - float(feach[2])
        tr = now - float(feach[6])
        if tt < 86400:
            tclr = f'{BGRN}'
        elif tt < 604800:
            tclr = f'{YEL}'
        else:
            tclr = f'{RED}'
        if tr < 604800:
            trclr = f'{BGRN}'
        elif tr < 2592000:
            trclr = f'{YEL}'
        else:
            trclr = f'{RED}'
        printplayer(feach)


def serverinfo(svr):
    global tclr
    global trclr
    c.execute('SELECT * from instances WHERE name = ?', (svr,))
    svrifo = c.fetchone()
    if not svrifo:
        print(f'{BMGT}{svr}{BRED} is not a server instance{RST}')
    else:
        sdata = fetcharkserverdata(svrifo[8])
        printarkserverdata(sdata)
        printserverinfo(svrifo)
        c.execute('SELECT * from players WHERE server = ?',(svr,))
        upo = c.fetchall()
        bcnt = 0
        for ueach in upo:
            if float(time.time()) - float(ueach[2]) < 3600:
                bcnt += 1
        if bcnt == 0:
            pp = f'{BRED}'
        else:
            pp = f'{BGRN}'
        print(f'{BCYN}NUMBER OF PLAYERS IN LAST HOUR: {pp}{bcnt}{RST}')
        print('    ')
        bcnt = 0
        for ueach in upo:
            if float(time.time()) - float(ueach[2]) < 86400:
                bcnt += 1
        if bcnt == 0:
            pp = f'{BRED}'
        else:
            pp = f'{BGRN}'
        print(f'{BCYN}NUMBER OF PLAYERS IN LAST DAY: {pp}{bcnt}{RST}')
        print('    ')
        bcnt = 0
        for ueach in upo:
            if float(time.time()) - float(ueach[2]) < 604800:
                bcnt += 1
        if bcnt == 0:
            pp = f'{BRED}'
        else:
            pp = f'{BGRN}'
        print(f'{BCYN}NUMBER OF PLAYERS IN LAST WEEK: {pp}{bcnt}{RST}')
        print('    ')

        print(f'{BCYN}LAST 10 PLAYERS ONLINE:{RST}')
        print('   ')
        c.execute('SELECT * from players WHERE server = ? ORDER BY lastseen DESC LIMIT 10', (svr,))
        lastones = c.fetchall()
        for feach in lastones:
            tt = now - float(feach[2])
            if tt < 300:
                tclr = f'{BGRN}'
            elif tt < 86400:
                tclr = f'{YEL}'
            else:
                tclr = f'{RED}'
            printplayer(feach)
        print('   ')
        print(f'{BCYN}LAST 5 NEWEST PLAYERS:{RST}')
        print('   ')
        c.execute('SELECT * from players WHERE server = ? ORDER BY firstseen DESC LIMIT 5', (svr,))
        lastones = c.fetchall()
        for feach in lastones:
            tt = now - float(feach[2])
            if tt < 300:
                tclr = f'{BGRN}'
            elif tt < 86400:
                tclr = f'{YEL}'
            else:
                tclr = f'{RED}'
            printplayer(feach)
        print('   ')


def playerage():
    print(f'{BCYN}PLAYERS BY LAST TIME SEEN:{RST}')
    print('    ')
    c.execute('SELECT * from players ORDER BY lastseen DESC')
    lastones = c.fetchall()
    for feach in lastones:
        tt = now - float(feach[2])
        tr = now - float(feach[6])
        if tt < 86400:
            tclr = f'{BGRN}'
        elif tt < 604800:
            tclr = f'{YEL}'
        else:
            tclr = f'{RED}'
        if tr < 604800:
            trclr = f'{BGRN}'
        elif tr < 2592000:
            trclr = f'{YEL}'
        else:
            trclr = f'{RED}'
        printplayer(feach)
    print('   ')


def follow(stream):
    line = ''
    try:
        for block in iter(lambda: stream.read(1024), None):
            if '\n' in block:
                for line in (line + block).splitlines(True) + ['']:
                    if line.endswith('\n'):
                        yield line.strip()
            elif not block:
                # Wait for data.
                time.sleep(1.0)
    except KeyboardInterrupt:
        print('Exited.')


def pyarklogs():
    arklog = subprocess.run('tail -%s /home/ark/shared/logs/pyark/pyark.log' % (args.loglines,),
                            stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, shell=True)
    for each in arklog.stdout.decode('utf-8').split('\n'):
        if each.find('[CRITICAL]') != -1:
            ar = f'{BRED}'
        elif each.find('[ERROR]') != -1:
            ar = f'{BRED}'
        elif each.find('[WARNING]') != -1:
            ar = f'{BYEL}'
        elif each.find('[INFO]') != -1:
            if each.find('svr1') != -1:
                ar = f'{WHT}'
            else:
                ar = f'{BWHT}'
        print(f'{ar}{each}{RST}')


def watchlog(dlog):
    if dlog is False:
        logpath = f'/home/ark/shared/logs/pyark/pyark.log'
    elif dlog is True:
        logpath = f'/home/ark/shared/logs/pyark/pyarkdebug.log'
    with open(logpath, 'rt') as following:
        following.seek(0, 0)
        for each in follow(following):
            if each.find('[CRITICAL]') != -1:
                ar = f'{RED}{LREV}'
            elif each.find('[ERROR]') != -1:
                ar = f'{BRED}'
            elif each.find('[WARNING]') != -1:
                ar = f'{BYEL}'
            elif each.find('[INFO]') != -1 or each.find('[DEBUG]'):
                if each.find('vote') != -1:
                    ar = f'{ORG}'
                elif each.find('arkupdater') != -1:
                    ar = f'{BLU}'
                elif each.find('lottery') != -1:
                    ar = f'{BGRN}'
                elif each.find('points') != -1:
                    ar = f'{MAU}'
                elif each.find('-restart') != -1:
                    ar = f'{MGT}'
                elif each.find('query') != -1:
                    ar = f'{SKN}'
                elif each.find('left the server') != -1:
                    ar = f'{PUR}'
                elif each.find('link') != -1:
                    ar = f'{SLT}'
                elif each.find('has joined') != -1 or each.find('transferred') != -1:
                    ar = f'{BGN}'
                elif each.find('svr1') != -1:
                    ar = f'{WHT}'
                else:
                    ar = f'{BWHT}'
            print(f'{ar}{each}{RST}')


def writechat(inst, whos, msg, tstamp):
    conn = sqlite3.connect(sqldb)
    c = conn.cursor()
    c.execute('SELECT * from players WHERE playername = ?', (whos,))
    isindb = c.fetchone()
    c.close()
    conn.close()
    if isindb:
        conn = sqlite3.connect(sqldb)
        c = conn.cursor()
        c.execute('INSERT INTO chatbuffer (server,name,message,timestamp) VALUES (?, ?, ?, ?)',
                  (inst, whos, msg, tstamp))
        conn.commit()
        c.close()
        conn.close()


def resetlastwipe(sinst):
    conn = sqlite3.connect(sqldb)
    c = conn.cursor()
    newtime = time.time()
    c.execute('UPDATE instances SET lastdinowipe = ? WHERE name = ?', (newtime, sinst))
    conn.commit()
    c.close()
    conn.close()


def initdinowipe(sinst):
    print(f'{BYEL}Initiating a Wild Dino Wipe on server {BMGT}{sinst.capitalize()}{RST}')
    resetlastwipe(sinst)
    subprocess.run('arkmanager rconcmd "ServerChat admin initated a wild dino wipe, wiping in 10 seconds" @%s' %
                   (sinst), shell=True)
    writechat(sinst, 'ALERT', f'### A wild dino wipe as been initiated by admin. Wiping wild dinos now.', wcstamp())
    time.sleep(10)
    subprocess.run('arkmanager rconcmd DestroyWildDinos @%s' % (sinst), stdout=subprocess.DEVNULL,
                   stderr=subprocess.DEVNULL, shell=True)
    time.sleep(2)


def backupdb():
    try:
        subprocess.run("""rm /home/ark/shared/db/pyark.db.old""", shell=True)
    except:
        pass
    subprocess.run("""/usr/bin/sqlite3 /home/ark/shared/db/pyark.db '.backup "/home/ark/shared/db/pyark.db.old"'""", shell=True)
    print(f'{BYEL}Database backed up to {sharedpath}/db/pyark.db.old{RST}')


def startlottery():
    listtable('lotteryinfo')
    print('    ')
    ltype = getresponce('Select Lottery Type (points / item) ')
    lbuyin = int(getresponce('Enter rewards points buyin amount '))
    ldays = int(getresponce('Enter lottery length in hours '))
    print('    ')
    print(f'{BGRN}Starting the new lottery:{RST}')
    print('    ')
    if ltype.lower() == 'item':
        litm = getresponce('Enter the Item display name ')
    else:
        litm = str(lbuyin * 4)
    now = time.time()
    lottostart = datetime.fromtimestamp(now + (3600 * int(ldays))).strftime('%a, %b %d %I:%M%p')
    print(f'{BYEL}Lottery ends on {BMGT}{lottostart}{RST}')
    print(f'{BYEL}Lottery Type: {BMGT}{ltype.capitalize()}{RST}')
    print(f'{BYEL}Lottery Prize: {BMGT}{litm}{RST}')
    print(f'{BYEL}Buyin Points: {BMGT}{lbuyin}{RST}')
    print(f'{BYEL}Lottery Length: {BMGT}{ldays} Hours{RST}')
    print('    ')
    conn = sqlite3.connect(sqldb)
    c = conn.cursor()
    newtime = time.time()
    c.execute('INSERT INTO lotteryinfo (type,payoutitem,timestamp,buyinpoints,lengthdays,players,winner) VALUES \
              (?,?,?,?,?,0,"Incomplete")', (ltype,litm,now,lbuyin,ldays))
    conn.commit()
    c.close()
    conn.close()


def lottery():
    conn = sqlite3.connect(sqldb)
    c = conn.cursor()
    c.execute('SELECT * FROM lotteryinfo ORDER BY id DESC LIMIT 1')
    lastlottery = c.fetchone()
    c.execute('SELECT * FROM lotteryinfo')
    lotteryinfo = c.fetchall()
    c.execute('SELECT * FROM lotteryplayers')
    lotteryplayers = c.fetchall()
    c.execute('SELECT * FROM lotterydeposits')
    lotterydeposits = c.fetchall()
    c.execute('SELECT * FROM players ORDER BY lottowins DESC LIMIT 5')
    lotterywins = c.fetchall()
    c.close()
    conn.close()
    plist = ''
    for row in lotteryplayers:
        if plist == '':
            plist = '%s' % (row[1])
        else:
            plist = plist + ', %s' % (row[1])
    now = time.time()
    lli = float(lastlottery[3]) + (3600 * int(lastlottery[5]))
    lottostart = estshift(datetime.fromtimestamp(lli)).strftime('%a, %b %d %I:%M%p')
    print('   ')
    print(f'{BCYN}TOP 5 WINNERS:')
    for peach in lotterywins:
        printplayer(peach)
    print(f'{BCYN}LOTTERY DEPOSITS/WITHDRAWS PENDING:{RST}')
    for leach in lotterydeposits:
        if int(leach[4]) == 0:
            ltype = f'{BRED}WITHDRAW{RST}'
        elif int(leach[4]) == 1:
            ltype = f'{BGRN}DEPOSIT{RST}'
        print(f'{BYEL}Player: {BMGT}{leach[1]} {BYEL}Type: {ltype} {BYEL}Amount: {BCYN}{leach[3]} {BYEL}Waiting: \
{BCYN}{elapsedTime(now,leach[2])}{RST}')
    print('   ')
    if lastlottery[7] == 'Incomplete':
        print(f'{BGRN}CURRENT LOTTERY UNDERWAY:{RST}')
        print(f'{BYEL}Lottery ends on {BMGT}{lottostart} {BCYN}({elapsedTime(lli, now)} Left){RST}')
        print(f'{BYEL}Lottery Type: {BMGT}{lastlottery[1].capitalize()}{RST}')
        print(f'{BYEL}Lottery Prize: {BMGT}{lastlottery[2]}{RST}')
        print(f'{BYEL}Buyin Points: {BMGT}{lastlottery[4]}{RST}')
        print(f'{BYEL}Lottery Length: {BMGT}{lastlottery[5]} Hours{RST}')
        print(f'{BYEL}Current Active Lottery Players: {BMGT}{lastlottery[6]}{RST}')
        print(f'{BYEL}Players: {BMGT}{plist}{RST}')
    else:
        print(f'{BRED}NO CURRENT LOTTERYS. LAST LOTTERY:{RST}')
        print(f'{BYEL}Winner was: {BGRN}{lastlottery[7].capitalize()}{RST}')
        print(f'{BYEL}Lottery ended on {BMGT}{lottostart} {BCYN}({elapsedTime(now, lli)} ago){RST}')
        print(f'{BYEL}Lottery Type: {BMGT}{lastlottery[1].capitalize()}{RST}')
        print(f'{BYEL}Lottery Prize: {BMGT}{lastlottery[2]}{RST}')
        print(f'{BYEL}Buyin Points: {BMGT}{lastlottery[4]}{RST}')
        print(f'{BYEL}Lottery Length: {BMGT}{lastlottery[5]} Hours{RST}')
        print(f'{BYEL}Participated Lottery Players: {BMGT}{lastlottery[6]}{RST}')
        print(f'{BYEL}Players: {BMGT}{plist}{RST}')
    print('   ')


try:
    if args.action_to_perform == 'servers':
        showservers()
    elif args.action_to_perform == 'playertable':
        printcolmns('players')
        listtable('players')
    elif args.action_to_perform == 'kicklist':
        printcolmns('kicklist')
        listtable('kicklist')
    elif args.action_to_perform == 'linkrequests':
        printcolmns('linkrequests')
        listtable('linkrequests')
    elif args.action_to_perform == 'lotterytables':
        printcolmns('lotteryinfo')
        listtable('lotteryinfo')
        print('    ')
        printcolmns('lotteryplayers')
        listtable('lotteryplayers')
        print('     ')
        printcolmns('lotterydeposits')
        listtable('lotterydeposits')
    elif args.action_to_perform == 'notlinked':
        listtable('players')
        listtablewhere('players', 'discordid', '')
    elif args.action_to_perform == 'discordnames':
        printcolmns('discordnames')
        listtable('discordnames')
    elif args.action_to_perform == 'restartserver':
        if args.servername == '':
            print('You must specify a server name with -s option.')
        else:
            restartserver(args.servername)
    elif args.action_to_perform == 'dinowipe':
        if args.servername == '':
            print('You must specify a server name with -s option.')
        else:
            initdinowipe(args.servername)
    elif args.action_to_perform == 'linkplayer':
        linkplayer()
    elif args.action_to_perform == 'delplayer':
        delplayer()
    elif args.action_to_perform == 'newest':
        newest()
    elif args.action_to_perform == 'server':
        if args.servername is None:
            print('You must specify a server name with -s option.')
        else:
            serverinfo(args.servername)
    elif args.action_to_perform == 'players':
        playerage()
    elif args.action_to_perform == 'servertable':
        printcolmns('instances')
        listtable('instances')
    elif args.action_to_perform == 'oldest':
        oldest()
    elif args.action_to_perform == 'chatbuffer':
        printcolmns('globalbuffer')
        listtable('globalbuffer')
    elif args.action_to_perform == 'playersraw':
        playersraw()
    elif args.action_to_perform == 'logwatch':
        watchlog(False)
    elif args.action_to_perform == 'debugwatch':
        watchlog(True)
    elif args.action_to_perform == 'logsearch':
        if args.searcharg is None:
            print('You must specify a search value with the -l option.')
        else:
            alogsearcher(args.searcharg)
    elif args.action_to_perform == 'banlist':
        banlist()
    elif args.action_to_perform == 'topplayers':
        topplayers()
    elif args.action_to_perform == 'lottery':
        lottery()
    elif args.action_to_perform == 'banplayer':
        banplayer()
    elif args.action_to_perform == 'unbanplayer':
        unbanplayer()
    elif args.action_to_perform == 'tribewipe':
        tribewipe()
    elif args.action_to_perform == 'backupdb':
        backupdb()
    elif args.action_to_perform == 'startlottery':
        startlottery()
    elif args.action_to_perform == 'log':
        if args.loglines is None:
            print('You must specify number of log lines to show with -j option.')
        else:
            pyarklogs()
    print('       ')
    c.close()
    conn.close()
except:
    log.critical('error!', exc_info=True)
    c.close()
    conn.close()
