#!/usr/bin/env python3.7

from arkupdater import arkupdater_thread
from clusterevents import eventwatcher_thread
from cmdlistener import cmdlistener_thread
from gchatrelay import gchatrelay_thread
from git import Repo
from kicker import kicker_thread
from modules.configreader import hstname, instances, jsonlogfile, is_asdatapuller, is_statscollector, is_eventwatcher, is_lotterymanager, loglevel, adminfile, jsondebugfile, pointsfile, colorlogfile, crashlogfile, critlogfile, instr, debugfile, chatlogfile, gamelogfile, is_gamelogger
from modules.dbhelper import dbupdate, dbquery
from modules.processlock import plock
from modules.servertools import serverexec
from modules.apihelper import steamapi_thread, auctionapi_thread, arkservernet_thread
from gamelogger import gamelogger_thread, dblcheckonline_thread
from onlinemonitor import onlinemonitor_thread
from statcollector import statcollector_thread
import sys
from time import sleep
from os import nice, stat, _exit
import argparse
from loguru import logger as log
import lottery
import threading
import signal
import shutil
import modules.logging


__author__ = "Ian Perry"
__copyright__ = "Copyright 2018, Galaxy Media"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Ian Perry"
__email__ = "ianperry99@gmail.com"
__progname__ = "pyark-daemon"
__description__ = "pyark daemon service"
__detaildesc__ = ""
__name__ = "pyark"

parser = argparse.ArgumentParser(prog=__progname__)
parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-q', '--quiet', action='store_true',
                    help='supress logging output to console. default: error logging')
parser.add_argument('-d', '--debug', action='store_true', help='verbose output (debug)')
parser.add_argument('-t', '--trace', action='store_true', help='super verbose output (trace)')

args = parser.parse_args()


def sig_handler(signal, frame):
    log.log('EXIT', f'Termination signal {signal} recieved. Exiting.')
    stop_event.set()
    log.debug(f'Waiting for {len(threads)} threads to exit...')
    for thread in threads:
        thread.join
    exit(0)


signal.signal(signal.SIGTERM, sig_handler)
signal.signal(signal.SIGHUP, sig_handler)
signal.signal(signal.SIGINT, sig_handler)
signal.signal(signal.SIGQUIT, sig_handler)


def checkdebuglog(record):
    if record['level'] == 'DEBUG' or record['level'] == 'TRACE':
        return True
    else:
        return False


def checkgamelog(record):
    if record['level'] == 'TRAP' or record['level'] == 'ADMIN' or record['level'] == 'DEATH' or record['level'] == 'TAME' or record['level'] == 'DECAY' or record['level'] == 'DEMO' or record['level'] == 'TRIBE' or record['level'] == 'CLAIM' or record['level'] == 'RELEASE':
        return True
    else:
        return False


def checklogadmin(record):
    if record['level'] == 'ADMIN':
        return True
    else:
        return False


def checkchatlog(record):
    if record['level'] == 'CHAT':
        return True
    else:
        return False


def checklogpoints(record):
    if record['level'] == 'POINTS':
        return True
    else:
        return False


def checklogcrash(record):
    if record['level'] == 'CRASH':
        return True
    else:
        return False


def checkerrorlog(record):
    if record['level'] == 'ERROR' or record['level'] == 'CRITICAL':
        return True
    else:
        return False


# Console Logging
if args.quiet:
    log.add(sink=sys.stderr, level=50, backtrace=False, diagnose=False, colorize=False, format=modules.logging.longlogformat)
elif args.trace:
    log.add(sink=sys.stdout, level=5, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)
elif args.debug:
    log.add(sink=sys.stdout, level=10, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)
else:
    log.add(sink=sys.stdout, level=20, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)

# Json logging pyarklog.json
log.add(sink=jsonlogfile, level=19, buffering=1, enqueue=True, backtrace=False, diagnose=False, serialize=True, colorize=True, format=modules.logging.shortlogformat)
# Color logging pyark.log
log.add(sink=colorlogfile, level=20, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=True, format=modules.logging.longlogformat)
# Debug json logging debuglog.json
if loglevel == 'DEBUG' or loglevel == 'TRACE' or args.debug or args.trace:
    if loglevel == 'DEBUG' or args.debug:
        lev = 10
    else:
        lev = 5
    log.add(sink=jsondebugfile, level=lev, buffering=1, enqueue=True, backtrace=True, diagnose=True, serialize=True, colorize=True, format=modules.logging.shortlogformat, delay=True, filter=checkdebuglog)
    log.add(sink=debugfile, level=lev, buffering=1, enqueue=True, backtrace=True, diagnose=True, serialize=False, colorize=True, format=modules.logging.longlogformat, delay=True)

# Points Logging points.log
log.add(sink=pointsfile, level=22, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogpoints)
# Admin Logging admin.log
log.add(sink=adminfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogadmin)
# Crash Logging crash.log
log.add(sink=crashlogfile, level=29, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogcrash)
# Error Logging error.log
log.add(sink=critlogfile, level=40, buffering=1, enqueue=True, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat, delay=True, filter=checkerrorlog)
# chat Logging error.log
log.add(sink=chatlogfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.chatlogformat, delay=False, filter=checkchatlog)
# game Logging game.log
log.add(sink=gamelogfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, serialize=False, colorize=True, format=modules.logging.gamelogformat, delay=False, filter=checkgamelog)


plock()

nice(10)

if loglevel == 'DEBUG' or args.debug:
    log.log('START', f'Pyark daemon is starting on {hstname} in **DEBUG MODE**')
elif loglevel == 'TRACE' or args.trace:
    log.log('START', f'Pyark daemon is starting on {hstname} in ***TRACE MODE***')
else:
    log.log('START', f'Pyark is starting on [{hstname}] for [{instr.title()}] in Normal Mode')

checkgit = 0


@log.catch
def gitupdatecheck():
    localdir = '/home/ark/pyark'
    repo = Repo(localdir)
    origin = repo.remotes.origin
    origin.fetch()
    if repo.head.commit != origin.refs[0].commit:
        log.log('GIT', f'New Pyark version found. Updating and Restarting...')
        origin.pull()
        # origin.push()
        serverexec(['systemctl', 'restart', 'pyark'], nice=0, null=True)


@log.catch
def checkthreads():
    for thread in threads:
        if not thread.is_alive():
            log.critical(f'!!!! CRITICAL ERROR! thread {thread.name} has crashed!!')


@log.catch
def main():
    log.debug(f'Pyark is sarting on {hstname.upper()}')
    global checkgit
    global instance
    global stop_event
    global threads
    threads = []
    stop_event = threading.Event()
    checklist = dbquery("SELECT name FROM instances", fmt='list', single=True)
    if not any(x in instances for x in checklist) and instr != 'Master Server':
        log.critical(f'Instance does not exist in the database!')
        exit(1)
    checkgit = 0
    log.trace('deleting global chat buffer')
    dbupdate('DELETE FROM globalbuffer')
    arkupdt = threading.Thread(name='arkupdater', target=arkupdater_thread, args=(stop_event,), daemon=False)
    threads.append(arkupdt)
    for inst in instances:
        thread = threading.Thread(name=f'{inst}-kicker', target=kicker_thread, args=(inst, 5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name=f'{inst}-cmdlistener', target=cmdlistener_thread, args=(inst, 2, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name=f'{inst}-gchatrelay', target=gchatrelay_thread, args=(inst, 5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name=f'{inst}-onlinemon', target=onlinemonitor_thread, args=(inst, 15, stop_event), daemon=False)
    if is_eventwatcher == "True":
        thread = threading.Thread(name='eventwatcher', target=eventwatcher_thread, args=(60, stop_event), daemon=False)
        threads.append(thread)
    if is_asdatapuller == "True":
        thread = threading.Thread(name='arkservernet', target=arkservernet_thread, args=(900, stop_event), daemon=False)
        threads.append(thread)
    if is_lotterymanager == "True":
        thread = threading.Thread(name='lotterywatcher', target=lottery.lotterywatcher_thread, args=(300, stop_event), daemon=False)
        threads.append(thread)
    if is_gamelogger == "True":
        thread = threading.Thread(name='gamelogger', target=gamelogger_thread, args=(stop_event,), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='steamapi', target=steamapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='auctionapi', target=auctionapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='dblcheckonline', target=dblcheckonline_thread, args=(30, stop_event), daemon=False)
        threads.append(thread)
    if is_statscollector == "True":
        thread = threading.Thread(name='stat-collector', target=statcollector_thread, args=(300, stop_event), daemon=False)
        threads.append(thread)
    log.debug(f'Starting {len(threads)} threads')
    for thread in threads:
        thread.start()
    log.debug('All threads have started')
    sleep(1)
    log.log('START', f'Pyark is ready and serving [{instr.title()}] on {hstname}...')

    while True:
        try:
            if shutil.disk_usage('/').free < 2000000000:
                log.critical('Root Disk under 2Gig. Shutting instance and script down')
                serverexec(['arkmanager', 'stop', '--warn', '@all'], null=True)
                serverexec(['/home/ark/pyark/pyarlcli', 'stop'], null=True)
                _exit(1)
        except:
            log.critical('unable to determine root freespace')
            sleep(60)
            _exit(1)
        try:
            if stat('/home/ark/shared/logs/pyark/pyark.log').st_size > 1000000000:
                log.critical('Pyark log over 1Gig. Shutting script down')
                serverexec(['/home/ark/pyark/pyarkcli', 'stop'], null=True)
                _exit(0)
        except:
            log.critical('unable to determine pyark log filesize')
            sleep(60)

        if checkgit == 0:
            # gitupdatecheck()
            checkgit += 1
        elif checkgit == 12:
            checkgit = 0
        else:
            checkgit += 1
        sleep(60)
        checkthreads()


if __name__ == 'pyark':
    # gitupdatecheck()
    gitcheck = 1
    main()
