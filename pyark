#!/usr/bin/python3

import logging, argparse, time, threading, socket
from sys import exit
# from git import Repo
from arkupdater import arkupd
from cmdlistener import clisten
from onlinemonitor import onlineupdate
from discordbot import discordbot
from statcollector import oscollect
from kicker import kicker
from configreader import logfile, instance, numinstances, imthedbot, restapi_enabled, restapi_ip, restapi_port
from gchatrelay import gchatrelay
from restapi import app
from arkserversnet import arkserversnet
from clusterevents import eventwatcher
from dbhelper import dbquery, dbupdate
import lottery
import processlock

__author__ = "Ian Perry"
__copyright__ = "Copyright 2018, Galaxy Media"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Ian Perry"
__email__ = "ianperry99@gmail.com"
__progname__ = "pyark-daemon"
__description__ = "pyark daemon service"
__detaildesc__ = ""

hstname = socket.gethostname()
log = logging.getLogger(name=hstname)

parser = argparse.ArgumentParser(prog=__progname__)
parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-q', '--quiet', action='store_true',
                    help='supress logging output to console. default: error logging')
parser.add_argument('--debug', action='store_true', help='verbose output (debug)')
args = parser.parse_args()
# if args.debug == True:  # changed to false to force debugging
log.setLevel(logging.DEBUG)
# else:
#    log.setLevel(logging.INFO)
console_format = logging.Formatter('%(asctime)s:[%(levelname)s]:%(name)s:%(threadName)s:%(message)s')
log_format = logging.Formatter('%(asctime)s:[%(levelname)s]:%(name)s:%(threadName)s:%(message)s')

if args.quiet is False:
    log_console = logging.StreamHandler()
    log_console.setLevel(logging.DEBUG)
    log.addHandler(log_console)
    log_console.setFormatter(console_format)
log_fileh = logging.FileHandler(logfile)
log_fileh.setLevel(logging.INFO)
log_fileh.setFormatter(log_format)

log_filej = logging.FileHandler('/home/ark/shared/logs/pyark/pyarkdebug.log')
log_filej.setFormatter(log_format)
log_filej.setLevel(logging.DEBUG)

log.addHandler(log_fileh)
log.addHandler(log_filej)

processlock.lock()

log.info(f'>>> pyark daemon is starting on {hstname}')

checkgit = 0


# def gitupdatecheck():
#    localdir = '/home/ark/pyark'
#    repo = Repo(localdir)
#    origin = repo.remotes.origin
#    origin.fetch()
#    if repo.head.commit != origin.refs[0].commit:
#        log.warning(f'newer pyark version found. updating and restarting...')
#        origin.pull()
#        origin.push()
#        subprocess.run('systemctl restart pyark', stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)


def main():
    global checkgit
    global instance
    dbupdate('CREATE TABLE IF NOT EXISTS general(cfgver TEXT)')
    dbupdate('CREATE TABLE IF NOT EXISTS instances(name TEXT, lastrestart REAL, lastdinowipe REAL, \
              needsrestart TEXT, lastvote REAL, restartreason TEXT, cfgver INTEGER, restartcountdown INTEGER)')
    dbupdate('CREATE TABLE IF NOT EXISTS players(steamid TEXT, playername TEXT, lastseen TEXT, server TEXT, \
              playedtime TEXT, rewardpoints INTEGER, firstseen TEXT, connects INTEGER)')
    for ins in range(numinstances):
        chkinst = dbquery('SELECT * FROM instances WHERE name = "%s"' % (instance[ins]['name'],))
        if not chkinst:
            now = time.time()
            log.warning(f'server {instance[ins]["name"]} does not exist in the server table. adding it.')
            dbupdate('INSERT INTO instances (name, lastrestart, lastdinowipe, needsrestart, lastvote) VALUES \
                      ("%s", "%s", "%s", "%s", "%s")' % (instance[ins]["name"], now, now, 'False', now))
        else:
            log.debug(f'found server {instance[ins]["name"]} in server table')
    log.debug('database initilization complete')
    checkgit = 0
    arkupdt = threading.Thread(name='arkupdater', target=arkupd)
    arkupdt.start()
    log.debug('deleting global chat buffer')
    dbupdate('DELETE FROM globalbuffer')
    for each in range(numinstances):
        inst = instance[each]['name']
        instance[each]['kickthread'] = threading.Thread(name='%s-kicker' % inst, target=kicker, args=(inst,))
        instance[each]['kickthread'].start()
        instance[each]['cmdthread'] = threading.Thread(name='%s-cmdlistener' % inst, target=clisten, args=(inst,))
        instance[each]['cmdthread'].start()
        instance[each]['gchatthread'] = threading.Thread(name='%s-gchatrelay' % inst, target=gchatrelay, args=(inst,))
        instance[each]['gchatthread'].start()
        instance[each]['onlinethread'] = threading.Thread(name='%s-onlinemon' % inst, target=onlineupdate, args=(inst,))
        instance[each]['onlinethread'].start()
        instance[each]['eventthread'] = threading.Thread(name='%s-events' % inst, target=eventwatcher, args=(inst,))
        instance[each]['eventthread'].start()
    if imthedbot == "True":
        arkserversnt = threading.Thread(name='arksvrnet-datapuller', target=arkserversnet)
        arkserversnt.start()
        discordt = threading.Thread(name='discord-bot', target=discordbot)
        discordt.start()
        lotteryt = threading.Thread(name='lottery-watcher', target=lottery.lotterywatcher)
        lotteryt.start()
        ostat = threading.Thread(name='stat-collector', target=oscollect)
        ostat.start()
    if restapi_enabled == "True" or restapi_enabled == "true":
        log.info(f'Starting RestAPI Server on IP: {restapi_ip} PORT: {restapi_port}')
        try:
            pass
            restapi = threading.Thread(name='restapi', target=app.run, kwargs={'host': restapi_ip, 'port': restapi_port})
            restapi.start()
        except:
            log.critical(f'Flask RestAPI failed to start.', exc_info=True)

    while True:
        try:
            if checkgit == 0:
                # gitupdatecheck()
                checkgit += 1
            elif checkgit == 61:
                checkgit = 0
            else:
                checkgit += 1
            time.sleep(60)
            for each in range(numinstances):
                log.debug(f'{instance[each]["name"]} {list(instance[each].keys())}')
            if not arkupdt.is_alive():
                t = 'ark updater'
                log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
            if imthedbot == "True":
                if not arkserversnt.is_alive():
                    t = 'arkserversnet datapuller'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
                if not discordt.is_alive():
                    t = 'discord bot'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
                if not lotteryt.is_alive():
                    t = 'lottery watch'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
                if not ostat.is_alive():
                    t = 'stat collector'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
            for each in range(numinstances):
                inst = instance[each]['name']
                if not instance[each]['cmdthread'].is_alive():
                    t = f'{inst} command listener'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
            for each in range(numinstances):
                inst = instance[each]['name']
                if not instance[each]['kickthread'].is_alive():
                    t = f'{inst} kicklist kicker'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
                if not instance[each]['gchatthread'].is_alive():
                    t = f'{inst} global chat relay'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
                if not instance[each]['onlinethread'].is_alive():
                    t = f'{inst} online monitor'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
                if not instance[each]['eventthread'].is_alive():
                    t = f'{inst} event monitor'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
            if restapi_enabled == "True" or restapi_enabled == "true":
                if not restapi.is_alive():
                    t = f'{inst} rest api'
                    log.critical(f'!!!! CRITICAL ERROR! thread {t} has crashed!!')
        except KeyboardInterrupt:
            log.critical(f'Keyboard Interrupt Exiting.')
            exit()
        except:
            log.critical(f'exception in main loop', exc_info=True)


if __name__ == '__main__':
    # gitupdatecheck()
    gitcheck = 1
    main()
