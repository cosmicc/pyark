#!/usr/bin/env python3.7

import argparse
import asyncio
import aiohttp
import signal
import sys
import threading
from os import _exit, nice, stat
from time import sleep, time

import uvloop
from git import Repo
from loguru import logger as log

import modules.logging
from modules.apihelper import arkservernet_thread, auctionapi_thread, steamapi_thread
from modules.arkupdater import arkupdater_thread
from modules.asyncdb import DB as db
from modules.clusterevents import eventwatcher_thread
from modules.cmdlistener import asynccmdcheck
from modules.configreader import (adminfile, chatlogfile, colorlogfile, crashlogfile, critlogfile,
                                  debugfile, gamelogfile, gamelograwfile, hstname, instances,
                                  instr, jsondebugfile, jsonlogfile, loglevel, pointsfile)
from modules.dbhelper import dbquery, dbupdate
from modules.gamelogger import dblcheckonline_thread, gamelogger_thread
from modules.gchatrelay import asyncgchatrelay
from modules.instances import instancelist
from modules.lottery import lotterywatcher_thread
from modules.onlinemonitor import asynckickcheck, asynconlinecheck
from modules.masterserver import asyncdblcheckonline, GameLogger
from modules.processlock import plock
from modules.servertools import serverexec
from modules.statcollector import statcollector_thread
from modules.timehelper import Secs

__author__ = "Ian Perry"
__copyright__ = "Copyright 2018, Galaxy Media"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Ian Perry"
__email__ = "ianperry99@gmail.com"
__progname__ = "pyark-daemon"
__description__ = "pyark daemon service"
__detaildesc__ = ""
__name__ = "pyark"

parser = argparse.ArgumentParser(prog=__progname__)
parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-q', '--quiet', action='store_true',
                    help='supress logging output to console. default: error logging')
parser.add_argument('-d', '--debug', action='store_true', help='verbose output (debug)')
parser.add_argument('-t', '--trace', action='store_true', help='super verbose output (trace)')

args = parser.parse_args()


def sig_handler(signal, frame):
    global main_stop_event
    log.log('EXIT', f'Termination signal {signal} recieved. Exiting.')
    main_stop_event = True
    stop_event.set()


signal.signal(signal.SIGTERM, sig_handler)
signal.signal(signal.SIGHUP, sig_handler)
signal.signal(signal.SIGINT, sig_handler)
signal.signal(signal.SIGQUIT, sig_handler)


def checkdebuglog(record):
    if record['level'] == 'DEBUG' or record['level'] == 'TRACE':
        return True
    else:
        return False


def checkgamelog(record):
    if record['level'] == 'TRAP' or record['level'] == 'ADMIN' or record['level'] == 'DEATH' or record['level'] == 'TAME' or record['level'] == 'DECAY' or record['level'] == 'DEMO' or record['level'] == 'TRIBE' or record['level'] == 'CLAIM' or record['level'] == 'RELEASE':
        return True
    else:
        return False


def checklogadmin(record):
    if record['level'] == 'ADMIN':
        return True
    else:
        return False


def checkchatlog(record):
    if record['level'] == 'CHAT':
        return True
    else:
        return False


def checklogpoints(record):
    if record['level'] == 'POINTS':
        return True
    else:
        return False


def checklogcrash(record):
    if record['level'] == 'CRASH':
        return True
    else:
        return False


def checkerrorlog(record):
    if record['level'] == 'ERROR' or record['level'] == 'CRITICAL':
        return True
    else:
        return False


# Console Logging
if args.quiet:
    log.add(sink=sys.stderr, level=50, backtrace=False, diagnose=False, colorize=False, format=modules.logging.longlogformat)
elif args.trace:
    log.add(sink=sys.stdout, level=5, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)
elif args.debug:
    log.add(sink=sys.stdout, level=10, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)
else:
    log.add(sink=sys.stdout, level=20, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)

# Json logging pyarklog.json
log.add(sink=jsonlogfile, level=19, buffering=1, enqueue=True, backtrace=False, diagnose=False, serialize=True, colorize=True, format=modules.logging.shortlogformat)
# Color logging pyark.log
log.add(sink=colorlogfile, level=20, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=True, format=modules.logging.longlogformat)
# Debug json logging debuglog.json
if loglevel == 'DEBUG' or loglevel == 'TRACE' or args.debug or args.trace:
    if loglevel == 'DEBUG' or args.debug:
        lev = 10
    else:
        lev = 5
    log.add(sink=jsondebugfile, level=lev, buffering=1, enqueue=True, backtrace=True, diagnose=True, serialize=True, colorize=True, format=modules.logging.shortlogformat, delay=True, filter=checkdebuglog)
    log.add(sink=debugfile, level=lev, buffering=1, enqueue=True, backtrace=True, diagnose=True, serialize=False, colorize=True, format=modules.logging.longlogformat, delay=True)

# Points Logging points.log
log.add(sink=pointsfile, level=22, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogpoints)
# Admin Logging admin.log
log.add(sink=adminfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogadmin)
# Crash Logging crash.log
log.add(sink=crashlogfile, level=29, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogcrash)
# Error Logging error.log
log.add(sink=critlogfile, level=40, buffering=1, enqueue=True, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat, delay=True, filter=checkerrorlog)
# chat Logging error.log
log.add(sink=chatlogfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.chatlogformat, delay=False, filter=checkchatlog)
# game Logging game.log
log.add(sink=gamelogfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, serialize=False, colorize=True, format=modules.logging.gamelogformat, delay=False, filter=checkgamelog)

plock()

nice(10)

if loglevel == 'DEBUG' or args.debug:
    log.log('START', f'Pyark daemon is starting on {hstname} in **DEBUG MODE**')
elif loglevel == 'TRACE' or args.trace:
    log.log('START', f'Pyark daemon is starting on {hstname} in ***TRACE MODE***')
else:
    log.log('START', f'Pyark is starting on [{hstname}] for [{instr.title()}] in Normal Mode')

checkgit = 0


@log.catch
def gitupdatecheck():
    localdir = '/home/ark/pyark'
    repo = Repo(localdir)
    origin = repo.remotes.origin
    origin.fetch()
    if repo.head.commit != origin.refs[0].commit:
        log.log('GIT', f'New Pyark version found. Updating and Restarting...')
        origin.pull()
        # origin.push()
        serverexec(['systemctl', 'restart', 'pyark'], nice=0, null=True)


@log.catch
def checkthreads():
    for thread in threads:
        if not thread.is_alive():
            log.critical(f'!!!! CRITICAL ERROR! thread {thread.name} has crashed!!')


def loop(asyncloop, delay, atinstances, gl=False):
    global timer
    if not gl:
        if asyncloop.time() - timer['kickcheck'] > delay['kickcheck']:
            asyncio.create_task(asynckickcheck(instances))
            # print(f'kickcheck wait time: {asyncloop.time() - timer["kickcheck"]}')
            timer.update({'kickcheck': asyncloop.time()})
        if asyncloop.time() - timer['cmdcheck'] > delay['cmdcheck']:
            asyncio.create_task(asynccmdcheck(instances, atinstances))
            # print(f'cmdcheck wait time: {asyncloop.time() - timer["cmdcheck"]}')
            timer.update({'cmdcheck': asyncloop.time()})
        if asyncloop.time() - timer['onlinecheck'] > delay['onlinecheck']:
            asyncio.create_task(asynconlinecheck(instances))
            # print(f'onlinehceck wait time: {asyncloop.time() - timer["onlinecheck"]}')
            timer.update({'onlinecheck': asyncloop.time()})
        if asyncloop.time() - timer['gchatrelay'] > delay['gchatrelay']:
            asyncio.create_task(asyncgchatrelay(instances))
            # print(f'gchatrelay wait time: {asyncloop.time() - timer["gchatrelay"]}')
            timer.update({'gchatrelay': asyncloop.time()})
    else:
        pass
        #gl = GameLogger()
        #if asyncloop.time() - dblcheck_timer > dblcheck_delay:
        #    asyncio.create_task(asyncdblcheckonline())
        #    dblcheck_timer = asyncloop.time()


async def asyncmain():
    global main_stop_event
    global timer
    main_stop_event = False
    delay = {'kickcheck': 5, 'cmdcheck': 2, 'onlinecheck': 10, 'gchatrelay': 2, 'dblcheck': 30}
    serverpre = ['@all']
    for each in instancelist():
        serverpre.append(f'@{each}')
    atinstances = tuple(serverpre)
    await db.connect()
    asyncloop = asyncio.get_running_loop()
    starttime = asyncloop.time()
    if len(instances) > 0:
        timer = {'kickcheck': starttime, 'gchatrelay': starttime, 'cmdcheck': starttime, 'onlinecheck': starttime}
    else:
        timer = {'dblcheck': starttime}
    log.log('START', f'Pyark is ready and serving [{instr.title()}] on {hstname}...')
    if len(instances) == 0:
        gl = GameLogger()
        async with aiohttp.ClientSession() as session:
            while not main_stop_event:
                loop(asyncloop, delay, atinstances, gl)
                await asyncio.sleep(.1)
    else:
        while not main_stop_event:
            loop(asyncloop, delay, atinstances, False)
            await asyncio.sleep(.1)

    #async with aiohttp.ClientSession() as session:
    #    asyncio.create_task(asyncdblcheckonline())
    #    asyncio.create_task(asyncstatcollector())
    #    asyncio.create_task(gl.process())
    #    asyncio.create_task(asynccheckdbconnections())
    #    asyncio.create_task(asyncauctionapi(session))

        await asyncio.sleep(.1)
    pendingtasks = asyncio.Task.all_tasks()
    tasklist = []
    for each in list(pendingtasks):
        if each != asyncio.Task.current_task():
            tasklist.append(each)

    log.debug(f'still running tasks: {list(pendingtasks)}')
    await db.close()
    return True


@log.catch
def main():
    log.debug(f'Pyark is sarting on {hstname.upper()}')
    global checkgit
    global instance
    global stop_event
    global threads
    global workers
    checkgit = 0
    threads = []
    workers = []
    stop_event = threading.Event()
    checklist = dbquery("SELECT name FROM instances", fmt='list', single=True)
    if not any(x in instances for x in checklist) and instr != 'Master Server':
        log.critical(f'Instance does not exist in the database!')
        exit(1)
    for each in instances:
        log.trace('deleting global chat buffer for {instance}')
        dbupdate("DELETE FROM globalbuffer WHERE server = '{each}'")
    arkupdt = threading.Thread(name='arkupdater', target=arkupdater_thread, args=(stop_event,), daemon=False)
    threads.append(arkupdt)
    if len(instances) == 0:
        thread = threading.Thread(name='eventwatcher', target=eventwatcher_thread, args=(1, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='arkservernet', target=arkservernet_thread, args=(Secs['15min'], stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='lotterywatcher', target=lotterywatcher_thread, args=(Secs['5min'], stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='gamelogger', target=gamelogger_thread, args=(stop_event,), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='steamapi', target=steamapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='auctionapi', target=auctionapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='dblcheckonline', target=dblcheckonline_thread, args=(30, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='stat-collector', target=statcollector_thread, args=(Secs['5min'], stop_event), daemon=False)
        threads.append(thread)
    log.debug(f'Starting {len(threads)} threads')
    for thread in threads:
        thread.start()
    log.debug('All threads have started')
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    asyncio.run(asyncmain())  # Async branch to main loop
    log.debug(f'Waiting for {len(threads)} threads to exit...')
    for thread in threads:
        thread.join
    log.debug('Pyark Exited.')
    exit(0)

    '''
    while True:
        try:
            if shutil.disk_usage('/').free < 2000000000:
                log.critical('Root Disk under 2Gig. Shutting instance and script down')
                serverexec(['arkmanager', 'stop', '--warn', '@all'], null=True)
                serverexec(['/home/ark/pyark/pyarlcli', 'stop'], null=True)
                _exit(1)
        except:
            log.critical('unable to determine root freespace')
            sleep(60)
            _exit(1)
        try:
            if stat('/home/ark/shared/logs/pyark/pyark.log').st_size > 1000000000:
                log.critical('Pyark log over 1Gig. Shutting script down')
                serverexec(['/home/ark/pyark/pyarkcli', 'stop'], null=True)
                _exit(0)
        except:
            log.critical('unable to determine pyark log filesize')
            sleep(60)

        if checkgit == 0:
            # gitupdatecheck()
            checkgit += 1
        elif checkgit == 12:
            checkgit = 0
        else:
            checkgit += 1
        sleep(60)
        checkthreads()
'''


if __name__ == 'pyark':
    # gitupdatecheck()
    gitcheck = 1
    main()
