#!/usr/bin/env python3.7
import argparse
import asyncio
import logging
import signal
import sys
import threading
import warnings
from os import _exit, nice, stat
from time import sleep, time

import aiohttp
import uvloop
from git import Repo
from loguru import logger as log

import globvars
import modules.logging
from modules.apihelper import arkservernet_thread, auctionapi_thread, steamapi_thread
from modules.arkupdater import asynccheckbackup, asynccheckmaint, asynccheckrestart, asynccheckupdates, asynccheckwipe
from modules.asyncdb import DB as db
from modules.clusterevents import eventwatcher_thread
from modules.cmdlistener import asynccmdcheck
from modules.configreader import (adminfile, chatlogfile, colorlogfile, crashlogfile, critlogfile,
                                  debugfile, gamelogfile, gamelograwfile, hstname, instances, instr,
                                  is_arkupdater, jsondebugfile, jsonlogfile, loglevel, pointsfile)
from modules.dbhelper import dbquery, dbupdate
from modules.gamelogger import dblcheckonline_thread, gamelogger_thread
from modules.gchatrelay import asyncgchatrelay
from modules.instances import asyncgetinststatus, instancelist
from modules.lottery import lotterywatcher_thread
from modules.masterserver import GameLogger
from modules.onlinemonitor import asynckickcheck, asynconlinecheck, asynconlinedblchecker
from modules.processlock import PLock
from modules.servertools import processinststats, processserverstats, serverexec
from modules.statcollector import statcollector_thread
from modules.timehelper import Secs

logging.basicConfig(level=logging.DEBUG)

__author__ = "Ian Perry"
__copyright__ = "Copyright 2018, Galaxy Media"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Ian Perry"
__email__ = "ianperry99@gmail.com"
__progname__ = "pyark-daemon"
__description__ = "pyark daemon service"
__detaildesc__ = ""
__name__ = "pyark"

parser = argparse.ArgumentParser(prog=__progname__)
parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-q', '--quiet', action='store_true',
                    help='supress logging output to console. default: error logging')
parser.add_argument('-d', '--debug', action='store_true', help='verbose output (debug)')
parser.add_argument('-t', '--trace', action='store_true', help='super verbose output (trace)')

args = parser.parse_args()


def sig_handler(signal, frame):
    global main_stop_event
    log.log('EXIT', f'Termination signal {signal} recieved. Exiting.')
    main_stop_event = True
    stop_event.set()


signal.signal(signal.SIGTERM, sig_handler)
signal.signal(signal.SIGHUP, sig_handler)
signal.signal(signal.SIGINT, sig_handler)
signal.signal(signal.SIGQUIT, sig_handler)

processlock = PLock()
processlock.lock()

nice(10)

if loglevel == 'DEBUG' or args.debug:
    log.log('START', f'Pyark daemon is starting on {hstname} in **DEBUG MODE**')
elif loglevel == 'TRACE' or args.trace:
    log.log('START', f'Pyark daemon is starting on {hstname} in ***TRACE MODE***')
else:
    log.log('START', f'Pyark is starting on [{hstname}] for [{instr.title()}] in Normal Mode')

checkgit = 0


@log.catch
def gitupdatecheck():
    localdir = '/home/ark/pyark'
    repo = Repo(localdir)
    origin = repo.remotes.origin
    origin.fetch()
    if repo.head.commit != origin.refs[0].commit:
        log.log('GIT', f'New Pyark version found. Updating and Restarting...')
        origin.pull()
        # origin.push()
        serverexec(['systemctl', 'restart', 'pyark'], nice=0, null=True)


@log.catch
def checkthreads():
    for thread in threads:
        if not thread.is_alive():
            log.critical(f'!!!! CRITICAL ERROR! thread {thread.name} has crashed!!')


async def asyncmain():
    global main_stop_event
    global file_event_notifier
    main_stop_event = False
    globvars.delay = {'serverstats': 60, 'statuscheck': 30, 'restartcheck': 30, 'backupcheck': 300, 'wipecheck': 60, 'updatecheck': 300, 'maintcheck': 300, 'kickcheck': 5, 'cmdcheck': 2, 'onlinecheck': 10, 'gchatrelay': 2, 'dblcheck': 30}
    if hstname == 'SVR1':
        globvars.delay.update({'cmdcheck': 5})
    serverpre = ['@all']
    for each in instancelist():
        serverpre.append(f'@{each}')
    atinstances = tuple(serverpre)
    await db.connect(process=__name__)
    asyncloop = asyncio.get_running_loop()
    starttime = asyncloop.time()
    tasktimer = asyncloop.time()
    if len(instances) == 0:
        log.debug(f'No ARK game instances found, running as [Master Bot]')
        globvars.timer = {'dblcheck': starttime}

        gl = GameLogger()
        async with aiohttp.ClientSession() as session:
            while not main_stop_event:
                await asyncio.sleep(1)
    else:
        globvars.timer = {'serverstats': starttime, 'statuscheck': starttime - 30, 'restartcheck': starttime, 'backupcheck': starttime, 'wipecheck': starttime, 'updatecheck': starttime, 'maintcheck': starttime, 'kickcheck': starttime, 'gchatrelay': starttime, 'cmdcheck': starttime, 'onlinecheck': starttime}
        log.debug(f'Found {len(instances)} ARK server instances: ({", ".join(instances).title()})')

        while not main_stop_event:
            asynclooptime = asyncloop.time()
            if asynclooptime - globvars.timer['statuscheck'] > globvars.delay['statuscheck']:
                asyncio.create_task(asyncgetinststatus(instances))
                if asynclooptime - globvars.timer['statuscheck'] > globvars.delay['statuscheck'] + 2:
                    log.error(f'statuscheck was delayed {asynclooptime - globvars.timer["statuscheck"] - globvars.delay["statuscheck"]}')
                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'statuscheck': asyncloop.time()})

            if asynclooptime - globvars.timer['kickcheck'] > globvars.delay['kickcheck']:
                asyncio.create_task(asynckickcheck(instances))
                if asynclooptime - globvars.timer['kickcheck'] > globvars.delay['kickcheck'] + 2:
                    log.error(f'kickcheck was delayed {asynclooptime - globvars.timer["kickcheck"] - globvars.delay["kickcheck"]}')
                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'kickcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['cmdcheck'] > globvars.delay['cmdcheck']:
                asyncio.create_task(asynccmdcheck(instances, atinstances))
                if asynclooptime - globvars.timer['cmdcheck'] > globvars.delay['cmdcheck'] + 2:
                    log.error(f'cmdcheck was delayed {asynclooptime - globvars.timer["cmdcheck"] - globvars.delay["cmdcheck"]}')
                # print(f'cmdcheck wait time: {asyncloop.time() - globvars.timer["cmdcheck"]}')
                globvars.timer.update({'cmdcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['onlinecheck'] > globvars.delay['onlinecheck']:
                asyncio.create_task(asynconlinecheck(instances))
                if asynclooptime - globvars.timer['onlinecheck'] > globvars.delay['onlinecheck'] + 2:
                    log.error(f'onlinecheck was delayed {asynclooptime - globvars.timer["onlinecheck"] - globvars.delay["onlinecheck"]}')
                # print(f'onlinehceck wait time: {asyncloop.time() - globvars.timer["onlinecheck"]}')
                asyncio.create_task(asynconlinedblchecker(instances))
                globvars.timer.update({'onlinecheck': asyncloop.time()})

            if asynclooptime - globvars.timer['gchatrelay'] > globvars.delay['gchatrelay']:
                asyncio.create_task(asyncgchatrelay(instances))
                if asynclooptime - globvars.timer['gchatrelay'] > globvars.delay['gchatrelay'] + 2:
                    log.error(f'gchatrelay was delayed {asynclooptime - globvars.timer["gchatrelay"] - globvars.delay["gchatrelay"]}')
                # print(f'gchatrelay wait time: {asyncloop.time() - globvars.timer["gchatrelay"]}')
                globvars.timer.update({'gchatrelay': asyncloop.time()})

            if asynclooptime - globvars.timer['wipecheck'] > globvars.delay['wipecheck']:
                asyncio.create_task(asynccheckwipe(instances))
                if asynclooptime - globvars.timer['wipecheck'] > globvars.delay['wipecheck'] + 2:
                    log.error(f'wipecheck was delayed {asynclooptime - globvars.timer["wipecheck"] - globvars.delay["wipecheck"]}')

                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'wipecheck': asyncloop.time()})

            if asynclooptime - globvars.timer['restartcheck'] > globvars.delay['restartcheck']:
                asyncio.create_task(asynccheckrestart(instances))
                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'restartcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['backupcheck'] > globvars.delay['backupcheck']:
                asyncio.create_task(asynccheckbackup(instances))
                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'backupcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['maintcheck'] > globvars.delay['maintcheck']:
                asyncio.create_task(asynccheckmaint(instances))
                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'maintcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['updatecheck'] > globvars.delay['updatecheck'] and is_arkupdater:
                asyncio.create_task(asynccheckupdates(instances))
                if asynclooptime - globvars.timer['updatecheck'] > globvars.delay['updatecheck'] + 2:
                    log.error(f'updatecheck was delayed {asynclooptime - globvars.timer["updatecheck"] - globvars.delay["updatecheck"]}')

                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'updatecheck': asyncloop.time()})

            if asynclooptime - globvars.timer['serverstats'] > globvars.delay['serverstats']:
                asyncio.create_task(processserverstats(instances))
                asyncio.create_task(processinststats(instances))
                if asynclooptime - globvars.timer['serverstats'] > globvars.delay['serverstats'] + 2:
                    log.error(f'serverstats was delayed {asynclooptime - globvars.timer["serverstats"] - globvars.delay["serverstats"]}')
                # print(f'kickcheck wait time: {asyncloop.time() - globvars.timer["kickcheck"]}')
                globvars.timer.update({'serverstats': asyncloop.time()})

            if asyncloop.time() - tasktimer > 60:
                if len(asyncio.Task.all_tasks()) > 30:
                    log.error(f'High number of async tasks running on {hstname} ({len(asyncio.Task.all_tasks())})')
                    tasktimer = asyncloop.time()
            await asyncio.sleep(.05)

    #async with aiohttp.ClientSession() as session:
    #    asyncio.create_task(asyncdblcheckonline())
    #    asyncio.create_task(asyncstatcollector())
    #    asyncio.create_task(gl.process())
    #    asyncio.create_task(asynccheckdbconnections())
    #    asyncio.create_task(asyncauctionapi(session))

        await asyncio.sleep(.1)
    # ending loop
    pendingtasks = asyncio.Task.all_tasks()
    log.debug(f'still running tasks: {pendingtasks}')
    if len(pendingtasks) > 1:
        log.debug(f'Waiting for {len(pendingtasks) - 1} async tasks to finish...')
        while len(asyncio.Task.all_tasks()) > 1:
            await asyncio.sleep(.1)
    else:
        log.debug(f'No async pending tasks to finish.')
    await db.close()
    return True


@log.catch
def main():
    log.debug(f'Pyark is sarting on {hstname.upper()}')
    global checkgit
    global instance
    global stop_event
    global threads
    checkgit = 0
    threads = []
    stop_event = threading.Event()
    checklist = dbquery("SELECT name FROM instances", fmt='list', single=True)
    if not any(x in instances for x in checklist) and instr != 'Master Server':
        log.critical(f'Instance does not exist in the database!')
        exit(1)
    for inst in instances:
        log.trace(f'deleting global chat buffer for {inst}')
        dbupdate(f"DELETE FROM globalbuffer WHERE server = '{inst}'")
    if len(instances) == 0:
        thread = threading.Thread(name='eventwatcher', target=eventwatcher_thread, args=(1, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='arkservernet', target=arkservernet_thread, args=(Secs['15min'], stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='lotterywatcher', target=lotterywatcher_thread, args=(Secs['5min'], stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='gamelogger', target=gamelogger_thread, args=(stop_event,), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='steamapi', target=steamapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='auctionapi', target=auctionapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        # thread = threading.Thread(name='dblcheckonline', target=dblcheckonline_thread, args=(30, stop_event), daemon=False)
        # threads.append(thread)
        thread = threading.Thread(name='stat-collector', target=statcollector_thread, args=(Secs['5min'], stop_event), daemon=False)
        threads.append(thread)
    log.debug(f'Starting {len(threads)} threads')
    for thread in threads:
        thread.start()
    log.debug('All threads have started')
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    if args.trace:
        warnings.simplefilter('always', ResourceWarning)
        asyncio.run(asyncmain(), debug=True)  # Async branch to main loop
    else:
        asyncio.run(asyncmain())
    log.debug(f'Waiting for {len(threads)} threads and tasks to exit...')
    for thread in threads:
        thread.join
    processlock.unlock()
    log.debug('Pyark Exited.')
    exit(0)

    '''
    while True:
        try:
            if shutil.disk_usage('/').free < 2000000000:
                log.critical('Root Disk under 2Gig. Shutting instance and script down')
                serverexec(['arkmanager', 'stop', '--warn', '@all'], null=True)
                serverexec(['/home/ark/pyark/pyarlcli', 'stop'], null=True)
                _exit(1)
        except:
            log.critical('unable to determine root freespace')
            sleep(60)
            _exit(1)
        try:
            if stat('/home/ark/shared/logs/pyark/pyark.log').st_size > 1000000000:
                log.critical('Pyark log over 1Gig. Shutting script down')
                serverexec(['/home/ark/pyark/pyarkcli', 'stop'], null=True)
                _exit(0)
        except:
            log.critical('unable to determine pyark log filesize')
            sleep(60)

        if checkgit == 0:
            # gitupdatecheck()
            checkgit += 1
        elif checkgit == 12:
            checkgit = 0
        else:
            checkgit += 1
        sleep(60)
        checkthreads()
'''


if __name__ == 'pyark':
    # gitupdatecheck()
    gitcheck = 1
    main()
