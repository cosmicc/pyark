#!/usr/bin/env python3.7
import argparse
import asyncio
import logging
import signal
import threading
import warnings
from os import nice

import aiohttp
import uvloop
from git import Repo
from loguru import logger as log

import globvars
import modules.logging
from modules.apihelper import arkservernet_thread, auctionapi_thread, steamapi_thread
from modules.arkupdater import asynccheckbackup, asynccheckmaint, asynccheckrestart, asynccheckupdates, asynccheckwipe
from modules.asyncdb import DB as db
from modules.clusterevents import eventwatcher_thread
from modules.cmdlistener import cmdscheck
from modules.configreader import (adminfile, chatlogfile, colorlogfile, crashlogfile, critlogfile,
                                  debugfile, gamelogfile, gamelograwfile, hstname, instances, instr,
                                  is_arkupdater, jsondebugfile, jsonlogfile, loglevel, pointsfile)
from modules.dbhelper import dbquery, dbupdate
from modules.gamelogger import gamelogger_thread
from modules.gchatrelay import asyncgchatrelay
from modules.instances import statuscheck
from modules.lottery import lotterywatcher_thread
from modules.masterserver import GameLogger
from modules.onlinemonitor import asynckickcheck, asynconlinedblchecker, onlinecheck
from modules.processlock import PLock
from modules.redis import Redis
from modules.servertools import asyncserverexec, processinststats, processserverstats
from modules.statcollector import statcollector_thread
from modules.timehelper import Secs

logging.basicConfig(level=logging.DEBUG)

__author__ = "Ian Perry"
__copyright__ = "Copyright 2018, Galaxy Media"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Ian Perry"
__email__ = "ianperry99@gmail.com"
__progname__ = "pyark-daemon"
__description__ = "pyark daemon service"
__detaildesc__ = ""
__name__ = "pyark"

parser = argparse.ArgumentParser(prog=__progname__)
parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-q', '--quiet', action='store_true',
                    help='supress logging output to console. default: error logging')
parser.add_argument('-d', '--debug', action='store_true', help='verbose output (debug)')
parser.add_argument('-t', '--trace', action='store_true', help='super verbose output (trace)')

args = parser.parse_args()

signals = (0, 'SIGHUP', 'SIGINT', 'SIGQUIT', 4, 5, 6, 7, 8, 'SIGKILL', 10, 11, 12, 13, 14, 'SIGTERM')


def async_exception_handler(loop, context):
    exception = context.get('exception')
    message = context.get('message')
    try:
        raise exception
    except:
        log.exception(message)
    # if isinstance(exception, ZeroDivisionError):
    #    pass


def signal_handler(signal, frame):
    global main_stop_event
    log.log('EXIT', f'Termination signal [{signals[signal]}] recieved. Exiting.')
    main_stop_event = True
    stop_event.set()


signal.signal(signal.SIGTERM, signal_handler)  # Graceful Shutdown
signal.signal(signal.SIGHUP, signal_handler)  # Reload/Restart
signal.signal(signal.SIGINT, signal_handler)  # Hard Exit
signal.signal(signal.SIGQUIT, signal_handler)  # Hard Exit

processlock = PLock()
processlock.lock()

nice(10)

if loglevel == 'DEBUG' or args.debug:
    log.log('START', f'Pyark daemon is starting on {hstname} in **DEBUG MODE**')
elif loglevel == 'TRACE' or args.trace:
    log.log('START', f'Pyark daemon is starting on {hstname} in ***TRACE MODE***')
else:
    log.log('START', f'Pyark is starting on [{hstname}] for [{instr.title()}] in Normal Mode')

checkgit = 0


@log.catch
async def gitupdatecheck():
    localdir = '/home/ark/pyark'
    repo = Repo(localdir)
    origin = repo.remotes.origin
    origin.fetch()
    if repo.head.commit != origin.refs[0].commit:
        log.log('GIT', f'New Pyark version found. Updating and Restarting...')
        origin.pull()
        await asyncserverexec(['systemctl', 'restart', 'pyark'], nice=0)


@log.catch
def checkthreads():
    for thread in threads:
        if not thread.is_alive():
            log.critical(f'!!!! CRITICAL ERROR! thread {thread.name} has crashed!!')


async def checkrediscommands(pubsub):
    response = await pubsub.get_message(timeout=0.01)
    if response is not None:
        if response['type'] == 'message':
            log.info(f'Recieved Command: {response["data"].decode()}')
            if response['data'].decode() == 'update':
                await gitupdatecheck()


async def asyncmain():
    global main_stop_event
    global file_event_notifier
    main_stop_event = False
    asyncloop = asyncio.get_running_loop()
    asyncloop.set_exception_handler(async_exception_handler)
    # for s in signals:
    #    asyncloop.add_signal_handler(s, lambda s=s: asyncio.create_task(async_signal_handler(s, asyncloop)))
    globvars.delay = {'serverstats': 60, 'statuscheck': 30, 'restartcheck': 30, 'backupcheck': 300, 'wipecheck': 60, 'updatecheck': 300, 'maintcheck': 300, 'kickcheck': 5, 'cmdcheck': 2, 'onlinecheck': 10, 'gchatrelay': 2, 'dblcheck': 30}
    if hstname == 'SVR1':
        globvars.delay.update({'cmdcheck': 5})
    await Redis.connect(__name__)
    redis = Redis.redis
    await db.connect(process=__name__)
    pubsub = redis.pubsub()
    for inst in instances:
        await pubsub.subscribe([f'{inst}-commands'])
    asyncloop = asyncio.get_running_loop()
    starttime = asyncloop.time()
    tasktimer = asyncloop.time()
    if len(instances) == 0:
        log.debug(f'No ARK game instances found, running as [Master Bot]')
        globvars.timer = {'dblcheck': starttime}

        gl = GameLogger()
        async with aiohttp.ClientSession() as session:
            while not main_stop_event:
                await asyncio.sleep(1)
    else:
        globvars.timer = {'serverstats': starttime, 'statuscheck': starttime - 30, 'restartcheck': starttime, 'backupcheck': starttime, 'wipecheck': starttime, 'updatecheck': starttime, 'maintcheck': starttime, 'kickcheck': starttime, 'gchatrelay': starttime, 'cmdcheck': starttime, 'onlinecheck': starttime}
        log.debug(f'Found {len(instances)} ARK server instances: ({", ".join(instances).title()})')

        while not main_stop_event:
            await checkrediscommands(pubsub)
            asynclooptime = asyncloop.time()
            if asynclooptime - globvars.timer['statuscheck'] > globvars.delay['statuscheck']:
                asyncio.create_task(statuscheck(instances))
                if asynclooptime - globvars.timer['statuscheck'] > globvars.delay['statuscheck'] + 2:
                    log.error(f'statuscheck was delayed {asynclooptime - globvars.timer["statuscheck"] - globvars.delay["statuscheck"]}')
                globvars.timer.update({'statuscheck': asyncloop.time()})

            if asynclooptime - globvars.timer['kickcheck'] > globvars.delay['kickcheck']:
                asyncio.create_task(asynckickcheck(instances))
                if asynclooptime - globvars.timer['kickcheck'] > globvars.delay['kickcheck'] + 2:
                    log.error(f'kickcheck was delayed {asynclooptime - globvars.timer["kickcheck"] - globvars.delay["kickcheck"]}')
                globvars.timer.update({'kickcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['cmdcheck'] > globvars.delay['cmdcheck']:
                asyncio.create_task(cmdscheck(instances))
                if asynclooptime - globvars.timer['cmdcheck'] > globvars.delay['cmdcheck'] + 2:
                    log.error(f'cmdcheck was delayed {asynclooptime - globvars.timer["cmdcheck"] - globvars.delay["cmdcheck"]}')
                globvars.timer.update({'cmdcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['onlinecheck'] > globvars.delay['onlinecheck']:
                asyncio.create_task(onlinecheck(instances))
                if asynclooptime - globvars.timer['onlinecheck'] > globvars.delay['onlinecheck'] + 2:
                    log.error(f'onlinecheck was delayed {asynclooptime - globvars.timer["onlinecheck"] - globvars.delay["onlinecheck"]}')
                asyncio.create_task(asynconlinedblchecker(instances))
                globvars.timer.update({'onlinecheck': asyncloop.time()})

            if asynclooptime - globvars.timer['gchatrelay'] > globvars.delay['gchatrelay']:
                asyncio.create_task(asyncgchatrelay(instances))
                if asynclooptime - globvars.timer['gchatrelay'] > globvars.delay['gchatrelay'] + 2:
                    log.error(f'gchatrelay was delayed {asynclooptime - globvars.timer["gchatrelay"] - globvars.delay["gchatrelay"]}')
                globvars.timer.update({'gchatrelay': asyncloop.time()})

            if asynclooptime - globvars.timer['wipecheck'] > globvars.delay['wipecheck']:
                asyncio.create_task(asynccheckwipe(instances))
                if asynclooptime - globvars.timer['wipecheck'] > globvars.delay['wipecheck'] + 2:
                    log.error(f'wipecheck was delayed {asynclooptime - globvars.timer["wipecheck"] - globvars.delay["wipecheck"]}')
                globvars.timer.update({'wipecheck': asyncloop.time()})

            if asynclooptime - globvars.timer['restartcheck'] > globvars.delay['restartcheck']:
                asyncio.create_task(asynccheckrestart(instances))
                globvars.timer.update({'restartcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['backupcheck'] > globvars.delay['backupcheck']:
                asyncio.create_task(asynccheckbackup(instances))
                globvars.timer.update({'backupcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['maintcheck'] > globvars.delay['maintcheck']:
                asyncio.create_task(asynccheckmaint(instances))
                globvars.timer.update({'maintcheck': asyncloop.time()})

            if asynclooptime - globvars.timer['updatecheck'] > globvars.delay['updatecheck'] and is_arkupdater:
                asyncio.create_task(asynccheckupdates(instances))
                if asynclooptime - globvars.timer['updatecheck'] > globvars.delay['updatecheck'] + 2:
                    log.error(f'updatecheck was delayed {asynclooptime - globvars.timer["updatecheck"] - globvars.delay["updatecheck"]}')
                globvars.timer.update({'updatecheck': asyncloop.time()})

            if asynclooptime - globvars.timer['serverstats'] > globvars.delay['serverstats']:
                asyncio.create_task(processserverstats(instances))
                asyncio.create_task(processinststats(instances))
                if asynclooptime - globvars.timer['serverstats'] > globvars.delay['serverstats'] + 2:
                    log.error(f'serverstats was delayed {asynclooptime - globvars.timer["serverstats"] - globvars.delay["serverstats"]}')
                globvars.timer.update({'serverstats': asyncloop.time()})

            if asyncloop.time() - tasktimer > 60:
                if len(asyncio.Task.all_tasks()) > 30:
                    log.error(f'High number of async tasks running on {hstname} ({len(asyncio.Task.all_tasks())})')
                    tasktimer = asyncloop.time()
            await asyncio.sleep(.05)
    tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()]
    log.debug(f'Waiting for {len(tasks)} async tasks to finish')
    await asyncio.gather(*tasks, return_exceptions=True)
    log.debug('All async tasks have finished')
    await asyncio.sleep(1)
    await db.close()


    #async with aiohttp.ClientSession() as session:
    #    asyncio.create_task(asyncdblcheckonline())
    #    asyncio.create_task(asyncstatcollector())
    #    asyncio.create_task(gl.process())
    #    asyncio.create_task(asynccheckdbconnections())
    #    asyncio.create_task(asyncauctionapi(session))

    # ending loop

    #log.debug(f'still running tasks: {asyncio.Task.all_tasks()}')
    #if len(asyncio.Task.all_tasks()) > 1:
    #    log.debug(f'Waiting for {len(asyncio.Task.all_tasks()) - 1} async tasks to finish...')
    #    while len(asyncio.Task.all_tasks()) > 1:
    #        await asyncio.sleep(.1)
    #else:
    #    log.debug(f'No async pending tasks to finish.')


@log.catch
def main():
    log.debug(f'Pyark is sarting on {hstname.upper()}')
    global checkgit
    global instance
    global stop_event
    global threads
    checkgit = 0
    threads = []
    stop_event = threading.Event()
    checklist = dbquery("SELECT name FROM instances", fmt='list', single=True)
    if not any(x in instances for x in checklist) and instr != 'Master Server':
        log.critical(f'Instance does not exist in the database!')
        exit(1)
    for inst in instances:
        log.trace(f'deleting global chat buffer for {inst}')
        dbupdate(f"DELETE FROM globalbuffer WHERE server = '{inst}'")
    if len(instances) == 0:
        thread = threading.Thread(name='eventwatcher', target=eventwatcher_thread, args=(1, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='arkservernet', target=arkservernet_thread, args=(Secs['15min'], stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='lotterywatcher', target=lotterywatcher_thread, args=(Secs['5min'], stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='gamelogger', target=gamelogger_thread, args=(stop_event,), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='steamapi', target=steamapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='auctionapi', target=auctionapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        # thread = threading.Thread(name='dblcheckonline', target=dblcheckonline_thread, args=(30, stop_event), daemon=False)
        # threads.append(thread)
        thread = threading.Thread(name='stat-collector', target=statcollector_thread, args=(Secs['5min'], stop_event), daemon=False)
        threads.append(thread)
    log.debug(f'Starting {len(threads)} threads')
    for thread in threads:
        thread.start()
    log.debug('All threads have started')
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    if args.trace:
        warnings.simplefilter('always', ResourceWarning)
        asyncio.run(asyncmain(), debug=True)  # Async branch to main loop
    else:
        asyncio.run(asyncmain())
    if len(threads) > 0:
        log.debug(f'Waiting for {len(threads)} threads and tasks to exit...')
        for thread in threads:
            thread.join
    processlock.unlock()
    log.debug('Pyark Finished.')
    exit(0)

    '''
    while True:
        try:
            if shutil.disk_usage('/').free < 2000000000:
                log.critical('Root Disk under 2Gig. Shutting instance and script down')
                serverexec(['arkmanager', 'stop', '--warn', '@all'], null=True)
                serverexec(['/home/ark/pyark/pyarlcli', 'stop'], null=True)
                _exit(1)
        except:
            log.critical('unable to determine root freespace')
            sleep(60)
            _exit(1)
        try:
            if stat('/home/ark/shared/logs/pyark/pyark.log').st_size > 1000000000:
                log.critical('Pyark log over 1Gig. Shutting script down')
                serverexec(['/home/ark/pyark/pyarkcli', 'stop'], null=True)
                _exit(0)
        except:
            log.critical('unable to determine pyark log filesize')
            sleep(60)

        if checkgit == 0:
            # gitupdatecheck()
            checkgit += 1
        elif checkgit == 12:
            checkgit = 0
        else:
            checkgit += 1
        sleep(60)
        checkthreads()
'''


if __name__ == 'pyark':
    # gitupdatecheck()
    gitcheck = 1
    main()
