#!/usr/bin/env python3.7

import argparse
import asyncio
import signal
import sys
import threading
from os import _exit, nice, stat
from time import sleep, time

import uvloop
from git import Repo
from loguru import logger as log

import modules.logging
from modules.apihelper import arkservernet_thread, auctionapi_thread, steamapi_thread
from modules.arkupdater import arkupdater_thread
from modules.asyncdb import DB as db
from modules.clusterevents import eventwatcher_thread
from modules.instances import instancelist
from modules.cmdlistener import asynccmdcheck
from modules.configreader import (adminfile, chatlogfile, colorlogfile, crashlogfile, critlogfile,
                                  debugfile, gamelogfile, gamelograwfile, hstname, instances, instr,
                                  jsondebugfile, jsonlogfile, loglevel, pointsfile)
from modules.dbhelper import dbquery, dbupdate
from modules.gamelogger import dblcheckonline_thread, gamelogger_thread
from modules.gchatrelay import gchatrelay_thread
from modules.lottery import lotterywatcher_thread
from modules.onlinemonitor import asynckickcheck, asynconlinecheck
from modules.processlock import plock
from modules.servertools import serverexec
from modules.statcollector import statcollector_thread

__author__ = "Ian Perry"
__copyright__ = "Copyright 2018, Galaxy Media"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Ian Perry"
__email__ = "ianperry99@gmail.com"
__progname__ = "pyark-daemon"
__description__ = "pyark daemon service"
__detaildesc__ = ""
__name__ = "pyark"

parser = argparse.ArgumentParser(prog=__progname__)
parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-q', '--quiet', action='store_true',
                    help='supress logging output to console. default: error logging')
parser.add_argument('-d', '--debug', action='store_true', help='verbose output (debug)')
parser.add_argument('-t', '--trace', action='store_true', help='super verbose output (trace)')

args = parser.parse_args()


def sig_handler(signal, frame):
    global main_stop_event
    log.log('EXIT', f'Termination signal {signal} recieved. Exiting.')
    main_stop_event = True
    stop_event.set()


signal.signal(signal.SIGTERM, sig_handler)
signal.signal(signal.SIGHUP, sig_handler)
signal.signal(signal.SIGINT, sig_handler)
signal.signal(signal.SIGQUIT, sig_handler)


def checkdebuglog(record):
    if record['level'] == 'DEBUG' or record['level'] == 'TRACE':
        return True
    else:
        return False


def checkgamelog(record):
    if record['level'] == 'TRAP' or record['level'] == 'ADMIN' or record['level'] == 'DEATH' or record['level'] == 'TAME' or record['level'] == 'DECAY' or record['level'] == 'DEMO' or record['level'] == 'TRIBE' or record['level'] == 'CLAIM' or record['level'] == 'RELEASE':
        return True
    else:
        return False


def checkgamelograw(record):
    if record['level'] == 'GLRAW':
        return True
    else:
        return False


def checklogadmin(record):
    if record['level'] == 'ADMIN':
        return True
    else:
        return False


def checkchatlog(record):
    if record['level'] == 'CHAT':
        return True
    else:
        return False


def checklogpoints(record):
    if record['level'] == 'POINTS':
        return True
    else:
        return False


def checklogcrash(record):
    if record['level'] == 'CRASH':
        return True
    else:
        return False


def checkerrorlog(record):
    if record['level'] == 'ERROR' or record['level'] == 'CRITICAL':
        return True
    else:
        return False


# Console Logging
if args.quiet:
    log.add(sink=sys.stderr, level=50, backtrace=False, diagnose=False, colorize=False, format=modules.logging.longlogformat)
elif args.trace:
    log.add(sink=sys.stdout, level=5, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)
elif args.debug:
    log.add(sink=sys.stdout, level=10, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)
else:
    log.add(sink=sys.stdout, level=20, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat)

# Json logging pyarklog.json
log.add(sink=jsonlogfile, level=19, buffering=1, enqueue=True, backtrace=False, diagnose=False, serialize=True, colorize=True, format=modules.logging.shortlogformat)
# Color logging pyark.log
log.add(sink=colorlogfile, level=20, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=True, format=modules.logging.longlogformat)
# Debug json logging debuglog.json
if loglevel == 'DEBUG' or loglevel == 'TRACE' or args.debug or args.trace:
    if loglevel == 'DEBUG' or args.debug:
        lev = 10
    else:
        lev = 5
    log.add(sink=jsondebugfile, level=lev, buffering=1, enqueue=True, backtrace=True, diagnose=True, serialize=True, colorize=True, format=modules.logging.shortlogformat, delay=True, filter=checkdebuglog)
    log.add(sink=debugfile, level=lev, buffering=1, enqueue=True, backtrace=True, diagnose=True, serialize=False, colorize=True, format=modules.logging.longlogformat, delay=True)

# Points Logging points.log
log.add(sink=pointsfile, level=22, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogpoints)
# Admin Logging admin.log
log.add(sink=adminfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogadmin)
# Crash Logging crash.log
log.add(sink=crashlogfile, level=29, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.simplelogformat, delay=True, filter=checklogcrash)
# Error Logging error.log
log.add(sink=critlogfile, level=40, buffering=1, enqueue=True, backtrace=True, diagnose=True, colorize=True, format=modules.logging.longlogformat, delay=True, filter=checkerrorlog)
# chat Logging error.log
log.add(sink=chatlogfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, colorize=False, format=modules.logging.chatlogformat, delay=False, filter=checkchatlog)
# game Logging game.log
log.add(sink=gamelogfile, level=3, buffering=1, enqueue=True, backtrace=False, diagnose=False, serialize=False, colorize=False, format=modules.logging.gamelogformat, delay=False, filter=checkgamelog)
# rawgame Logging gamelog.raw
log.add(sink=gamelograwfile, level=1, buffering=1, enqueue=True, backtrace=False, diagnose=False, serialize=False, colorize=False, format=modules.logging.glrawlogformat, delay=False, filter=checkgamelograw)

plock()

nice(10)

if loglevel == 'DEBUG' or args.debug:
    log.log('START', f'Pyark daemon is starting on {hstname} in **DEBUG MODE**')
elif loglevel == 'TRACE' or args.trace:
    log.log('START', f'Pyark daemon is starting on {hstname} in ***TRACE MODE***')
else:
    log.log('START', f'Pyark is starting on [{hstname}] for [{instr.title()}] in Normal Mode')

checkgit = 0


@log.catch
def gitupdatecheck():
    localdir = '/home/ark/pyark'
    repo = Repo(localdir)
    origin = repo.remotes.origin
    origin.fetch()
    if repo.head.commit != origin.refs[0].commit:
        log.log('GIT', f'New Pyark version found. Updating and Restarting...')
        origin.pull()
        # origin.push()
        serverexec(['systemctl', 'restart', 'pyark'], nice=0, null=True)


@log.catch
def checkthreads():
    for thread in threads:
        if not thread.is_alive():
            log.critical(f'!!!! CRITICAL ERROR! thread {thread.name} has crashed!!')


async def faketestwork():
    await asyncio.sleep(900)


async def asyncmainloop():
    global main_stop_event
    main_stop_event = False
    kickcheck_delay = 5
    cmdcheck_delay = 2
    onlinecheck_delay = 10
    asyncloop = asyncio.get_running_loop()
    await db.connect()
    starttime = asyncloop.time()
    kickcheck_timer, cmdcheck_timer, onlinecheck_timer = starttime, starttime, starttime
    serverpre = ['@all']
    for each in instancelist():
        serverpre.append(f'@{each}')
    atinstances = tuple(serverpre)
    log.log('START', instances)
    log.log('START', f'Pyark is ready and serving [{instr.title()}] on {hstname}...')
    asyncio.create_task(faketestwork())
    while not main_stop_event:
        if asyncloop.time() - kickcheck_timer > kickcheck_delay and len(instances) > 0:
            asyncio.create_task(asynckickcheck(instances))
            kickcheck_timer = asyncloop.time()
        if asyncloop.time() - cmdcheck_timer > cmdcheck_delay and len(instances) > 0:
            asyncio.create_task(asynccmdcheck(instances, atinstances))
            cmdcheck_timer = asyncloop.time()
        if asyncloop.time() - onlinecheck_timer > onlinecheck_delay and len(instances) > 0:
            asyncio.create_task(asynconlinecheck(instances))
            onlinecheck_timer = asyncloop.time()
        await asyncio.sleep(.1)
    pendingtasks = asyncio.Task.all_tasks()
    tasklist = []
    for each in pendingtasks:
        if each != asyncio.Task.current_task():
            tasklist.append(each)
    # currenttask = asyncio.Task.current_task()

    log.debug(f'still running tasks: {list(pendingtasks)}')
    await db.close()
    return True


@log.catch
def main():
    log.debug(f'Pyark is sarting on {hstname.upper()}')
    global checkgit
    global instance
    global stop_event
    global threads
    threads = []
    stop_event = threading.Event()
    checklist = dbquery("SELECT name FROM instances", fmt='list', single=True)
    if not any(x in instances for x in checklist) and instr != 'Master Server':
        log.critical(f'Instance does not exist in the database!')
        exit(1)
    checkgit = 0
    log.trace('deleting global chat buffer')
    dbupdate('DELETE FROM globalbuffer')
    arkupdt = threading.Thread(name='arkupdater', target=arkupdater_thread, args=(stop_event,), daemon=False)
    threads.append(arkupdt)
    if len(instances) == 0:
        thread = threading.Thread(name='eventwatcher', target=eventwatcher_thread, args=(60, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='arkservernet', target=arkservernet_thread, args=(900, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='lotterywatcher', target=lotterywatcher_thread, args=(300, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='gamelogger', target=gamelogger_thread, args=(stop_event,), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='steamapi', target=steamapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='auctionapi', target=auctionapi_thread, args=(5, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='dblcheckonline', target=dblcheckonline_thread, args=(30, stop_event), daemon=False)
        threads.append(thread)
        thread = threading.Thread(name='stat-collector', target=statcollector_thread, args=(300, stop_event), daemon=False)
        threads.append(thread)
    log.debug(f'Starting {len(threads)} threads')
    for thread in threads:
        thread.start()
    log.debug('All threads have started')
    sleep(1)
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    asyncio.run(asyncmainloop())
    log.debug(f'Waiting for {len(threads)} threads to exit...')
    for thread in threads:
        thread.join
    log.debug('Pyark Exited.')
    exit(0)

    #thread = threading.Thread(name=f'{inst}-gchatrelay', target=gchatrelay_thread, args=(inst, 5, stop_event), daemon=False)
    #threads.append(thread)

    '''
    while True:
        try:
            if shutil.disk_usage('/').free < 2000000000:
                log.critical('Root Disk under 2Gig. Shutting instance and script down')
                serverexec(['arkmanager', 'stop', '--warn', '@all'], null=True)
                serverexec(['/home/ark/pyark/pyarlcli', 'stop'], null=True)
                _exit(1)
        except:
            log.critical('unable to determine root freespace')
            sleep(60)
            _exit(1)
        try:
            if stat('/home/ark/shared/logs/pyark/pyark.log').st_size > 1000000000:
                log.critical('Pyark log over 1Gig. Shutting script down')
                serverexec(['/home/ark/pyark/pyarkcli', 'stop'], null=True)
                _exit(0)
        except:
            log.critical('unable to determine pyark log filesize')
            sleep(60)

        if checkgit == 0:
            # gitupdatecheck()
            checkgit += 1
        elif checkgit == 12:
            checkgit = 0
        else:
            checkgit += 1
        sleep(60)
        checkthreads()
'''


if __name__ == 'pyark':
    # gitupdatecheck()
    gitcheck = 1
    main()
